/* Server_SoapH.h
   Generated by gSOAP 2.8.31 for F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#ifndef Server_SoapH_H
#define Server_SoapH_H
#include "Server_SoapStub.h"
#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap*, const void*, int);

#ifdef __cplusplus
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap*);
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap*);
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void *SOAP_FMAC4 soap_getelement(struct soap*, int*);
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap*, const void*, const char*, int, int);

#ifdef __cplusplus
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap*);

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap);
SOAP_FMAC3 void * SOAP_FMAC4 Server_Soap_instantiate(struct soap*, int, const char*, const char*, size_t*);
SOAP_FMAC3 int SOAP_FMAC4 Server_Soap_fdelete(struct soap_clist*);
SOAP_FMAC3 int SOAP_FMAC4 Server_Soap_fbase(int, int);
SOAP_FMAC3 void SOAP_FMAC4 Server_Soap_finsert(struct soap*, int, int, void*, size_t, const void*, void**);

#ifndef SOAP_TYPE_byte_DEFINED
#define SOAP_TYPE_byte_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap*, char *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap*, const char*, int, const char *, const char*);
SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap*, const char*, char *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap*, const char *, const char*, const char*);

inline int soap_write_byte(struct soap *soap, char const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_byte(soap, p, "byte", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap*, char *, const char*, const char*);

inline int soap_read_byte(struct soap *soap, char *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_byte(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__int_DEFINED
#define SOAP_TYPE_xsd__int_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__int(struct soap*, int *);

#define soap_xsd__int2s soap_int2s

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap*, const char*, int, const int *, const char*);

#define soap_s2xsd__int soap_s2int

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_xsd__int(struct soap*, const char*, int *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__int(struct soap*, const int *, const char*, const char*);

inline int soap_write_xsd__int(struct soap *soap, int const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__int(soap, p, "xsd:int", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 int * SOAP_FMAC4 soap_get_xsd__int(struct soap*, int *, const char*, const char*);

inline int soap_read_xsd__int(struct soap *soap, int *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__int(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_int_DEFINED
#define SOAP_TYPE_int_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap*, int *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap*, const char*, int, const int *, const char*);
SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap*, const char*, int *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap*, const int *, const char*, const char*);

inline int soap_write_int(struct soap *soap, int const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_int(soap, p, "int", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap*, int *, const char*, const char*);

inline int soap_read_int(struct soap *soap, int *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_int(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_long_DEFINED
#define SOAP_TYPE_long_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap*, long *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap*, const char*, int, const long *, const char*);
SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap*, const char*, long *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap*, const long *, const char*, const char*);

inline int soap_write_long(struct soap *soap, long const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_long(soap, p, "long", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap*, long *, const char*, const char*);

inline int soap_read_long(struct soap *soap, long *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_long(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__long_DEFINED
#define SOAP_TYPE_xsd__long_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__long(struct soap*, LONG64 *);

#define soap_xsd__long2s soap_LONG642s

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long(struct soap*, const char*, int, const LONG64 *, const char*);

#define soap_s2xsd__long soap_s2LONG64

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_xsd__long(struct soap*, const char*, LONG64 *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__long(struct soap*, const LONG64 *, const char*, const char*);

inline int soap_write_xsd__long(struct soap *soap, LONG64 const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__long(soap, p, "xsd:long", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_xsd__long(struct soap*, LONG64 *, const char*, const char*);

inline int soap_read_xsd__long(struct soap *soap, LONG64 *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__long(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_LONG64_DEFINED
#define SOAP_TYPE_LONG64_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap*, LONG64 *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap*, const char*, int, const LONG64 *, const char*);
SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap*, const char*, LONG64 *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap*, const LONG64 *, const char*, const char*);

inline int soap_write_LONG64(struct soap *soap, LONG64 const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_LONG64(soap, p, "long", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap*, LONG64 *, const char*, const char*);

inline int soap_read_LONG64(struct soap *soap, LONG64 *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_LONG64(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_float_DEFINED
#define SOAP_TYPE_float_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap*, float *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap*, const char*, int, const float *, const char*);
SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap*, const char*, float *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap*, const float *, const char*, const char*);

inline int soap_write_float(struct soap *soap, float const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_float(soap, p, "float", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap*, float *, const char*, const char*);

inline int soap_read_float(struct soap *soap, float *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_float(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__double_DEFINED
#define SOAP_TYPE_xsd__double_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__double(struct soap*, double *);

#define soap_xsd__double2s soap_double2s

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double(struct soap*, const char*, int, const double *, const char*);

#define soap_s2xsd__double soap_s2double

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_xsd__double(struct soap*, const char*, double *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__double(struct soap*, const double *, const char*, const char*);

inline int soap_write_xsd__double(struct soap *soap, double const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__double(soap, p, "xsd:double", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 double * SOAP_FMAC4 soap_get_xsd__double(struct soap*, double *, const char*, const char*);

inline int soap_read_xsd__double(struct soap *soap, double *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__double(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_double_DEFINED
#define SOAP_TYPE_double_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap*, double *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap*, const char*, int, const double *, const char*);
SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap*, const char*, double *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap*, const double *, const char*, const char*);

inline int soap_write_double(struct soap *soap, double const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_double(soap, p, "double", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap*, double *, const char*, const char*);

inline int soap_read_double(struct soap *soap, double *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_double(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__dateTime_DEFINED
#define SOAP_TYPE_xsd__dateTime_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__dateTime(struct soap*, time_t *);

#define soap_xsd__dateTime2s soap_dateTime2s

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap*, const char*, int, const time_t *, const char*);

#define soap_s2xsd__dateTime soap_s2dateTime

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_xsd__dateTime(struct soap*, const char*, time_t *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__dateTime(struct soap*, const time_t *, const char*, const char*);

inline int soap_write_xsd__dateTime(struct soap *soap, time_t const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__dateTime(soap, p, "xsd:dateTime", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap*, time_t *, const char*, const char*);

inline int soap_read_xsd__dateTime(struct soap *soap, time_t *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__dateTime(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_dateTime_DEFINED
#define SOAP_TYPE_dateTime_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_dateTime(struct soap*, time_t *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap*, const char*, int, const time_t *, const char*);
SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap*, const char*, time_t *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap*, const time_t *, const char*, const char*);

inline int soap_write_dateTime(struct soap *soap, time_t const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_dateTime(soap, p, "dateTime", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap*, time_t *, const char*, const char*);

inline int soap_read_dateTime(struct soap *soap, time_t *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_dateTime(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__KeyType_DEFINED
#define SOAP_TYPE_ns__KeyType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__KeyType(struct soap*, enum ns__KeyType *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__KeyType(struct soap*, const char*, int, const enum ns__KeyType *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__KeyType2s(struct soap*, enum ns__KeyType);
SOAP_FMAC3 enum ns__KeyType * SOAP_FMAC4 soap_in_ns__KeyType(struct soap*, const char*, enum ns__KeyType *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__KeyType(struct soap*, const char*, enum ns__KeyType *);

inline enum ns__KeyType * soap_new_ns__KeyType(struct soap *soap, int n = -1)
{
	return static_cast<enum ns__KeyType *>(soap_malloc(soap, (n < 0 ? 1 : n) * sizeof(enum ns__KeyType)));
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__KeyType(struct soap*, const enum ns__KeyType *, const char*, const char*);

inline int soap_write_ns__KeyType(struct soap *soap, enum ns__KeyType const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_ns__KeyType(soap, p, "ns:KeyType", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 enum ns__KeyType * SOAP_FMAC4 soap_get_ns__KeyType(struct soap*, enum ns__KeyType *, const char*, const char*);

inline int soap_read_ns__KeyType(struct soap *soap, enum ns__KeyType *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_ns__KeyType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__RequestType_DEFINED
#define SOAP_TYPE_ns__RequestType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__RequestType(struct soap*, enum ns__RequestType *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__RequestType(struct soap*, const char*, int, const enum ns__RequestType *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__RequestType2s(struct soap*, enum ns__RequestType);
SOAP_FMAC3 enum ns__RequestType * SOAP_FMAC4 soap_in_ns__RequestType(struct soap*, const char*, enum ns__RequestType *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__RequestType(struct soap*, const char*, enum ns__RequestType *);

inline enum ns__RequestType * soap_new_ns__RequestType(struct soap *soap, int n = -1)
{
	return static_cast<enum ns__RequestType *>(soap_malloc(soap, (n < 0 ? 1 : n) * sizeof(enum ns__RequestType)));
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__RequestType(struct soap*, const enum ns__RequestType *, const char*, const char*);

inline int soap_write_ns__RequestType(struct soap *soap, enum ns__RequestType const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_ns__RequestType(soap, p, "ns:RequestType", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 enum ns__RequestType * SOAP_FMAC4 soap_get_ns__RequestType(struct soap*, enum ns__RequestType *, const char*, const char*);

inline int soap_read_ns__RequestType(struct soap *soap, enum ns__RequestType *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_ns__RequestType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__DeviceModel_DEFINED
#define SOAP_TYPE_ns__DeviceModel_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DeviceModel(struct soap*, enum ns__DeviceModel *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceModel(struct soap*, const char*, int, const enum ns__DeviceModel *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__DeviceModel2s(struct soap*, enum ns__DeviceModel);
SOAP_FMAC3 enum ns__DeviceModel * SOAP_FMAC4 soap_in_ns__DeviceModel(struct soap*, const char*, enum ns__DeviceModel *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__DeviceModel(struct soap*, const char*, enum ns__DeviceModel *);

inline enum ns__DeviceModel * soap_new_ns__DeviceModel(struct soap *soap, int n = -1)
{
	return static_cast<enum ns__DeviceModel *>(soap_malloc(soap, (n < 0 ? 1 : n) * sizeof(enum ns__DeviceModel)));
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DeviceModel(struct soap*, const enum ns__DeviceModel *, const char*, const char*);

inline int soap_write_ns__DeviceModel(struct soap *soap, enum ns__DeviceModel const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_ns__DeviceModel(soap, p, "ns:DeviceModel", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 enum ns__DeviceModel * SOAP_FMAC4 soap_get_ns__DeviceModel(struct soap*, enum ns__DeviceModel *, const char*, const char*);

inline int soap_read_ns__DeviceModel(struct soap *soap, enum ns__DeviceModel *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_ns__DeviceModel(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__SensorName_DEFINED
#define SOAP_TYPE_ns__SensorName_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SensorName(struct soap*, enum ns__SensorName *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SensorName(struct soap*, const char*, int, const enum ns__SensorName *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__SensorName2s(struct soap*, enum ns__SensorName);
SOAP_FMAC3 enum ns__SensorName * SOAP_FMAC4 soap_in_ns__SensorName(struct soap*, const char*, enum ns__SensorName *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__SensorName(struct soap*, const char*, enum ns__SensorName *);

inline enum ns__SensorName * soap_new_ns__SensorName(struct soap *soap, int n = -1)
{
	return static_cast<enum ns__SensorName *>(soap_malloc(soap, (n < 0 ? 1 : n) * sizeof(enum ns__SensorName)));
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SensorName(struct soap*, const enum ns__SensorName *, const char*, const char*);

inline int soap_write_ns__SensorName(struct soap *soap, enum ns__SensorName const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_ns__SensorName(soap, p, "ns:SensorName", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 enum ns__SensorName * SOAP_FMAC4 soap_get_ns__SensorName(struct soap*, enum ns__SensorName *, const char*, const char*);

inline int soap_read_ns__SensorName(struct soap *soap, enum ns__SensorName *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_ns__SensorName(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__SensorType_DEFINED
#define SOAP_TYPE_ns__SensorType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SensorType(struct soap*, enum ns__SensorType *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SensorType(struct soap*, const char*, int, const enum ns__SensorType *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__SensorType2s(struct soap*, enum ns__SensorType);
SOAP_FMAC3 enum ns__SensorType * SOAP_FMAC4 soap_in_ns__SensorType(struct soap*, const char*, enum ns__SensorType *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__SensorType(struct soap*, const char*, enum ns__SensorType *);

inline enum ns__SensorType * soap_new_ns__SensorType(struct soap *soap, int n = -1)
{
	return static_cast<enum ns__SensorType *>(soap_malloc(soap, (n < 0 ? 1 : n) * sizeof(enum ns__SensorType)));
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SensorType(struct soap*, const enum ns__SensorType *, const char*, const char*);

inline int soap_write_ns__SensorType(struct soap *soap, enum ns__SensorType const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_ns__SensorType(soap, p, "ns:SensorType", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 enum ns__SensorType * SOAP_FMAC4 soap_get_ns__SensorType(struct soap*, enum ns__SensorType *, const char*, const char*);

inline int soap_read_ns__SensorType(struct soap *soap, enum ns__SensorType *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_ns__SensorType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__SimcardType_DEFINED
#define SOAP_TYPE_ns__SimcardType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SimcardType(struct soap*, enum ns__SimcardType *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SimcardType(struct soap*, const char*, int, const enum ns__SimcardType *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__SimcardType2s(struct soap*, enum ns__SimcardType);
SOAP_FMAC3 enum ns__SimcardType * SOAP_FMAC4 soap_in_ns__SimcardType(struct soap*, const char*, enum ns__SimcardType *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__SimcardType(struct soap*, const char*, enum ns__SimcardType *);

inline enum ns__SimcardType * soap_new_ns__SimcardType(struct soap *soap, int n = -1)
{
	return static_cast<enum ns__SimcardType *>(soap_malloc(soap, (n < 0 ? 1 : n) * sizeof(enum ns__SimcardType)));
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SimcardType(struct soap*, const enum ns__SimcardType *, const char*, const char*);

inline int soap_write_ns__SimcardType(struct soap *soap, enum ns__SimcardType const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_ns__SimcardType(soap, p, "ns:SimcardType", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 enum ns__SimcardType * SOAP_FMAC4 soap_get_ns__SimcardType(struct soap*, enum ns__SimcardType *, const char*, const char*);

inline int soap_read_ns__SimcardType(struct soap *soap, enum ns__SimcardType *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_ns__SimcardType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__UserType_DEFINED
#define SOAP_TYPE_ns__UserType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__UserType(struct soap*, enum ns__UserType *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UserType(struct soap*, const char*, int, const enum ns__UserType *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__UserType2s(struct soap*, enum ns__UserType);
SOAP_FMAC3 enum ns__UserType * SOAP_FMAC4 soap_in_ns__UserType(struct soap*, const char*, enum ns__UserType *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__UserType(struct soap*, const char*, enum ns__UserType *);

inline enum ns__UserType * soap_new_ns__UserType(struct soap *soap, int n = -1)
{
	return static_cast<enum ns__UserType *>(soap_malloc(soap, (n < 0 ? 1 : n) * sizeof(enum ns__UserType)));
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__UserType(struct soap*, const enum ns__UserType *, const char*, const char*);

inline int soap_write_ns__UserType(struct soap *soap, enum ns__UserType const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_ns__UserType(soap, p, "ns:UserType", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 enum ns__UserType * SOAP_FMAC4 soap_get_ns__UserType(struct soap*, enum ns__UserType *, const char*, const char*);

inline int soap_read_ns__UserType(struct soap *soap, enum ns__UserType *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_ns__UserType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__SettingLevel_DEFINED
#define SOAP_TYPE_ns__SettingLevel_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SettingLevel(struct soap*, enum ns__SettingLevel *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SettingLevel(struct soap*, const char*, int, const enum ns__SettingLevel *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__SettingLevel2s(struct soap*, enum ns__SettingLevel);
SOAP_FMAC3 enum ns__SettingLevel * SOAP_FMAC4 soap_in_ns__SettingLevel(struct soap*, const char*, enum ns__SettingLevel *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__SettingLevel(struct soap*, const char*, enum ns__SettingLevel *);

inline enum ns__SettingLevel * soap_new_ns__SettingLevel(struct soap *soap, int n = -1)
{
	return static_cast<enum ns__SettingLevel *>(soap_malloc(soap, (n < 0 ? 1 : n) * sizeof(enum ns__SettingLevel)));
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SettingLevel(struct soap*, const enum ns__SettingLevel *, const char*, const char*);

inline int soap_write_ns__SettingLevel(struct soap *soap, enum ns__SettingLevel const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_ns__SettingLevel(soap, p, "ns:SettingLevel", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 enum ns__SettingLevel * SOAP_FMAC4 soap_get_ns__SettingLevel(struct soap*, enum ns__SettingLevel *, const char*, const char*);

inline int soap_read_ns__SettingLevel(struct soap *soap, enum ns__SettingLevel *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_ns__SettingLevel(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__boolean_DEFINED
#define SOAP_TYPE_xsd__boolean_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap*, bool *);

#define soap_xsd__boolean2s soap_bool2s

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap*, const char*, int, const bool *, const char*);

#define soap_s2xsd__boolean soap_s2bool

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_xsd__boolean(struct soap*, const char*, bool *, const char*);

inline bool * soap_new_xsd__boolean(struct soap *soap, int n = -1)
{
	return static_cast<bool *>(soap_malloc(soap, (n < 0 ? 1 : n) * sizeof(bool)));
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap*, const bool *, const char*, const char*);

inline int soap_write_xsd__boolean(struct soap *soap, bool const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__boolean(soap, p, "xsd:boolean", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_xsd__boolean(struct soap*, bool *, const char*, const char*);

inline int soap_read_xsd__boolean(struct soap *soap, bool *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__boolean(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_bool_DEFINED
#define SOAP_TYPE_bool_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap*, bool *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap*, const char*, int, const bool *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap*, bool);
SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap*, const char*, bool *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap*, const char*, bool *);

inline bool * soap_new_bool(struct soap *soap, int n = -1)
{
	return static_cast<bool *>(soap_malloc(soap, (n < 0 ? 1 : n) * sizeof(bool)));
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap*, const bool *, const char*, const char*);

inline int soap_write_bool(struct soap *soap, bool const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_bool(soap, p, "boolean", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap*, bool *, const char*, const char*);

inline int soap_read_bool(struct soap *soap, bool *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_bool(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__AllCityLocatoins_DEFINED
#define SOAP_TYPE_ns__AllCityLocatoins_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AllCityLocatoins(struct soap*, const char*, int, const ns__AllCityLocatoins *, const char*);
SOAP_FMAC3 ns__AllCityLocatoins * SOAP_FMAC4 soap_in_ns__AllCityLocatoins(struct soap*, const char*, ns__AllCityLocatoins *, const char*);
SOAP_FMAC1 ns__AllCityLocatoins * SOAP_FMAC2 Server_Soap_instantiate_ns__AllCityLocatoins(struct soap*, int, const char*, const char*, size_t*);

inline ns__AllCityLocatoins * soap_new_ns__AllCityLocatoins(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__AllCityLocatoins(soap, n, NULL, NULL, NULL);
}

inline ns__AllCityLocatoins * soap_new_req_ns__AllCityLocatoins(
	struct soap *soap,
	const ns__ErrorCode& allCityLocatoinsError)
{
	ns__AllCityLocatoins *_p = soap_new_ns__AllCityLocatoins(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__AllCityLocatoins::allCityLocatoinsError = allCityLocatoinsError;
	}
	return _p;
}

inline ns__AllCityLocatoins * soap_new_set_ns__AllCityLocatoins(
	struct soap *soap,
	const std::vector<ns__CityLocation> & allCityLocatoins,
	const ns__ErrorCode& allCityLocatoinsError)
{
	ns__AllCityLocatoins *_p = soap_new_ns__AllCityLocatoins(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__AllCityLocatoins::allCityLocatoins = allCityLocatoins;
		_p->ns__AllCityLocatoins::allCityLocatoinsError = allCityLocatoinsError;
	}
	return _p;
}

inline int soap_write_ns__AllCityLocatoins(struct soap *soap, ns__AllCityLocatoins const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:AllCityLocatoins", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__AllCityLocatoins * SOAP_FMAC4 soap_get_ns__AllCityLocatoins(struct soap*, ns__AllCityLocatoins *, const char*, const char*);

inline int soap_read_ns__AllCityLocatoins(struct soap *soap, ns__AllCityLocatoins *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__AllCityLocatoins(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__CityLocation_DEFINED
#define SOAP_TYPE_ns__CityLocation_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__CityLocation(struct soap*, const char*, int, const ns__CityLocation *, const char*);
SOAP_FMAC3 ns__CityLocation * SOAP_FMAC4 soap_in_ns__CityLocation(struct soap*, const char*, ns__CityLocation *, const char*);
SOAP_FMAC1 ns__CityLocation * SOAP_FMAC2 Server_Soap_instantiate_ns__CityLocation(struct soap*, int, const char*, const char*, size_t*);

inline ns__CityLocation * soap_new_ns__CityLocation(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__CityLocation(soap, n, NULL, NULL, NULL);
}

inline ns__CityLocation * soap_new_req_ns__CityLocation(
	struct soap *soap,
	const ns__ErrorCode& cityLocationError)
{
	ns__CityLocation *_p = soap_new_ns__CityLocation(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__CityLocation::cityLocationError = cityLocationError;
	}
	return _p;
}

inline ns__CityLocation * soap_new_set_ns__CityLocation(
	struct soap *soap,
	const std::string& cityLocationCityName,
	const std::vector<std::string> & cityLocationLocationsName,
	const ns__ErrorCode& cityLocationError)
{
	ns__CityLocation *_p = soap_new_ns__CityLocation(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__CityLocation::cityLocationCityName = cityLocationCityName;
		_p->ns__CityLocation::cityLocationLocationsName = cityLocationLocationsName;
		_p->ns__CityLocation::cityLocationError = cityLocationError;
	}
	return _p;
}

inline int soap_write_ns__CityLocation(struct soap *soap, ns__CityLocation const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:CityLocation", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__CityLocation * SOAP_FMAC4 soap_get_ns__CityLocation(struct soap*, ns__CityLocation *, const char*, const char*);

inline int soap_read_ns__CityLocation(struct soap *soap, ns__CityLocation *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__CityLocation(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__ServerOptions_DEFINED
#define SOAP_TYPE_ns__ServerOptions_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ServerOptions(struct soap*, const char*, int, const ns__ServerOptions *, const char*);
SOAP_FMAC3 ns__ServerOptions * SOAP_FMAC4 soap_in_ns__ServerOptions(struct soap*, const char*, ns__ServerOptions *, const char*);
SOAP_FMAC1 ns__ServerOptions * SOAP_FMAC2 Server_Soap_instantiate_ns__ServerOptions(struct soap*, int, const char*, const char*, size_t*);

inline ns__ServerOptions * soap_new_ns__ServerOptions(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__ServerOptions(soap, n, NULL, NULL, NULL);
}

inline ns__ServerOptions * soap_new_req_ns__ServerOptions(
	struct soap *soap,
	const ns__DataBaseInfo& serverOptionsDataBaseInfo,
	const ns__ErrorCode& serverOptionsError)
{
	ns__ServerOptions *_p = soap_new_ns__ServerOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__ServerOptions::serverOptionsDataBaseInfo = serverOptionsDataBaseInfo;
		_p->ns__ServerOptions::serverOptionsError = serverOptionsError;
	}
	return _p;
}

inline ns__ServerOptions * soap_new_set_ns__ServerOptions(
	struct soap *soap,
	const ns__DataBaseInfo& serverOptionsDataBaseInfo,
	int serverOptionsTimeRepeat,
	const ns__ErrorCode& serverOptionsError)
{
	ns__ServerOptions *_p = soap_new_ns__ServerOptions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__ServerOptions::serverOptionsDataBaseInfo = serverOptionsDataBaseInfo;
		_p->ns__ServerOptions::serverOptionsTimeRepeat = serverOptionsTimeRepeat;
		_p->ns__ServerOptions::serverOptionsError = serverOptionsError;
	}
	return _p;
}

inline int soap_write_ns__ServerOptions(struct soap *soap, ns__ServerOptions const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:ServerOptions", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__ServerOptions * SOAP_FMAC4 soap_get_ns__ServerOptions(struct soap*, ns__ServerOptions *, const char*, const char*);

inline int soap_read_ns__ServerOptions(struct soap *soap, ns__ServerOptions *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__ServerOptions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__DataBaseInfo_DEFINED
#define SOAP_TYPE_ns__DataBaseInfo_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DataBaseInfo(struct soap*, const char*, int, const ns__DataBaseInfo *, const char*);
SOAP_FMAC3 ns__DataBaseInfo * SOAP_FMAC4 soap_in_ns__DataBaseInfo(struct soap*, const char*, ns__DataBaseInfo *, const char*);
SOAP_FMAC1 ns__DataBaseInfo * SOAP_FMAC2 Server_Soap_instantiate_ns__DataBaseInfo(struct soap*, int, const char*, const char*, size_t*);

inline ns__DataBaseInfo * soap_new_ns__DataBaseInfo(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__DataBaseInfo(soap, n, NULL, NULL, NULL);
}

inline ns__DataBaseInfo * soap_new_req_ns__DataBaseInfo(
	struct soap *soap,
	const ns__ErrorCode& dataBaseInfoError)
{
	ns__DataBaseInfo *_p = soap_new_ns__DataBaseInfo(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__DataBaseInfo::dataBaseInfoError = dataBaseInfoError;
	}
	return _p;
}

inline ns__DataBaseInfo * soap_new_set_ns__DataBaseInfo(
	struct soap *soap,
	const std::string& dataBaseInfoServerName,
	int dataBaseInfoPort,
	const std::string& dataBaseInfoUserName,
	const std::string& dataBaseInfoPassWord,
	const ns__ErrorCode& dataBaseInfoError)
{
	ns__DataBaseInfo *_p = soap_new_ns__DataBaseInfo(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__DataBaseInfo::dataBaseInfoServerName = dataBaseInfoServerName;
		_p->ns__DataBaseInfo::dataBaseInfoPort = dataBaseInfoPort;
		_p->ns__DataBaseInfo::dataBaseInfoUserName = dataBaseInfoUserName;
		_p->ns__DataBaseInfo::dataBaseInfoPassWord = dataBaseInfoPassWord;
		_p->ns__DataBaseInfo::dataBaseInfoError = dataBaseInfoError;
	}
	return _p;
}

inline int soap_write_ns__DataBaseInfo(struct soap *soap, ns__DataBaseInfo const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:DataBaseInfo", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__DataBaseInfo * SOAP_FMAC4 soap_get_ns__DataBaseInfo(struct soap*, ns__DataBaseInfo *, const char*, const char*);

inline int soap_read_ns__DataBaseInfo(struct soap *soap, ns__DataBaseInfo *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__DataBaseInfo(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__UserDevice_DEFINED
#define SOAP_TYPE_ns__UserDevice_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UserDevice(struct soap*, const char*, int, const ns__UserDevice *, const char*);
SOAP_FMAC3 ns__UserDevice * SOAP_FMAC4 soap_in_ns__UserDevice(struct soap*, const char*, ns__UserDevice *, const char*);
SOAP_FMAC1 ns__UserDevice * SOAP_FMAC2 Server_Soap_instantiate_ns__UserDevice(struct soap*, int, const char*, const char*, size_t*);

inline ns__UserDevice * soap_new_ns__UserDevice(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__UserDevice(soap, n, NULL, NULL, NULL);
}

inline ns__UserDevice * soap_new_req_ns__UserDevice(
	struct soap *soap,
	const ns__User& userDeviceUser,
	const ns__UserDevices& userDeviceDevices,
	const ns__ErrorCode& userDeviceError)
{
	ns__UserDevice *_p = soap_new_ns__UserDevice(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__UserDevice::userDeviceUser = userDeviceUser;
		_p->ns__UserDevice::userDeviceDevices = userDeviceDevices;
		_p->ns__UserDevice::userDeviceError = userDeviceError;
	}
	return _p;
}

inline ns__UserDevice * soap_new_set_ns__UserDevice(
	struct soap *soap,
	const ns__User& userDeviceUser,
	const ns__UserDevices& userDeviceDevices,
	const ns__ErrorCode& userDeviceError)
{
	ns__UserDevice *_p = soap_new_ns__UserDevice(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__UserDevice::userDeviceUser = userDeviceUser;
		_p->ns__UserDevice::userDeviceDevices = userDeviceDevices;
		_p->ns__UserDevice::userDeviceError = userDeviceError;
	}
	return _p;
}

inline int soap_write_ns__UserDevice(struct soap *soap, ns__UserDevice const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:UserDevice", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__UserDevice * SOAP_FMAC4 soap_get_ns__UserDevice(struct soap*, ns__UserDevice *, const char*, const char*);

inline int soap_read_ns__UserDevice(struct soap *soap, ns__UserDevice *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__UserDevice(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__UserDevices_DEFINED
#define SOAP_TYPE_ns__UserDevices_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UserDevices(struct soap*, const char*, int, const ns__UserDevices *, const char*);
SOAP_FMAC3 ns__UserDevices * SOAP_FMAC4 soap_in_ns__UserDevices(struct soap*, const char*, ns__UserDevices *, const char*);
SOAP_FMAC1 ns__UserDevices * SOAP_FMAC2 Server_Soap_instantiate_ns__UserDevices(struct soap*, int, const char*, const char*, size_t*);

inline ns__UserDevices * soap_new_ns__UserDevices(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__UserDevices(soap, n, NULL, NULL, NULL);
}

inline ns__UserDevices * soap_new_req_ns__UserDevices(
	struct soap *soap,
	const ns__ErrorCode& userDeviceError)
{
	ns__UserDevices *_p = soap_new_ns__UserDevices(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__UserDevices::userDeviceError = userDeviceError;
	}
	return _p;
}

inline ns__UserDevices * soap_new_set_ns__UserDevices(
	struct soap *soap,
	const std::vector<ns__DeviceRules> & userDevices,
	const ns__ErrorCode& userDeviceError)
{
	ns__UserDevices *_p = soap_new_ns__UserDevices(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__UserDevices::userDevices = userDevices;
		_p->ns__UserDevices::userDeviceError = userDeviceError;
	}
	return _p;
}

inline int soap_write_ns__UserDevices(struct soap *soap, ns__UserDevices const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:UserDevices", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__UserDevices * SOAP_FMAC4 soap_get_ns__UserDevices(struct soap*, ns__UserDevices *, const char*, const char*);

inline int soap_read_ns__UserDevices(struct soap *soap, ns__UserDevices *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__UserDevices(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__DeviceRules_DEFINED
#define SOAP_TYPE_ns__DeviceRules_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceRules(struct soap*, const char*, int, const ns__DeviceRules *, const char*);
SOAP_FMAC3 ns__DeviceRules * SOAP_FMAC4 soap_in_ns__DeviceRules(struct soap*, const char*, ns__DeviceRules *, const char*);
SOAP_FMAC1 ns__DeviceRules * SOAP_FMAC2 Server_Soap_instantiate_ns__DeviceRules(struct soap*, int, const char*, const char*, size_t*);

inline ns__DeviceRules * soap_new_ns__DeviceRules(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__DeviceRules(soap, n, NULL, NULL, NULL);
}

inline ns__DeviceRules * soap_new_req_ns__DeviceRules(
	struct soap *soap,
	const ns__Device& userDeviceDevice)
{
	ns__DeviceRules *_p = soap_new_ns__DeviceRules(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__DeviceRules::userDeviceDevice = userDeviceDevice;
	}
	return _p;
}

inline ns__DeviceRules * soap_new_set_ns__DeviceRules(
	struct soap *soap,
	const ns__Device& userDeviceDevice,
	bool userDeviceView,
	bool userDeviceUpdate,
	bool userDeviceDelete)
{
	ns__DeviceRules *_p = soap_new_ns__DeviceRules(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__DeviceRules::userDeviceDevice = userDeviceDevice;
		_p->ns__DeviceRules::userDeviceView = userDeviceView;
		_p->ns__DeviceRules::userDeviceUpdate = userDeviceUpdate;
		_p->ns__DeviceRules::userDeviceDelete = userDeviceDelete;
	}
	return _p;
}

inline int soap_write_ns__DeviceRules(struct soap *soap, ns__DeviceRules const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:DeviceRules", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__DeviceRules * SOAP_FMAC4 soap_get_ns__DeviceRules(struct soap*, ns__DeviceRules *, const char*, const char*);

inline int soap_read_ns__DeviceRules(struct soap *soap, ns__DeviceRules *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__DeviceRules(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__ErrorLog_DEFINED
#define SOAP_TYPE_ns__ErrorLog_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ErrorLog(struct soap*, const char*, int, const ns__ErrorLog *, const char*);
SOAP_FMAC3 ns__ErrorLog * SOAP_FMAC4 soap_in_ns__ErrorLog(struct soap*, const char*, ns__ErrorLog *, const char*);
SOAP_FMAC1 ns__ErrorLog * SOAP_FMAC2 Server_Soap_instantiate_ns__ErrorLog(struct soap*, int, const char*, const char*, size_t*);

inline ns__ErrorLog * soap_new_ns__ErrorLog(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__ErrorLog(soap, n, NULL, NULL, NULL);
}

inline ns__ErrorLog * soap_new_req_ns__ErrorLog(
	struct soap *soap,
	time_t errorLogDateTime,
	const ns__Device& errorLogDevice,
	const ns__ErrorCode& errorLogError)
{
	ns__ErrorLog *_p = soap_new_ns__ErrorLog(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__ErrorLog::errorLogDateTime = errorLogDateTime;
		_p->ns__ErrorLog::errorLogDevice = errorLogDevice;
		_p->ns__ErrorLog::errorLogError = errorLogError;
	}
	return _p;
}

inline ns__ErrorLog * soap_new_set_ns__ErrorLog(
	struct soap *soap,
	time_t errorLogDateTime,
	const ns__Device& errorLogDevice,
	const std::string& errorLogType,
	const ns__ErrorCode& errorLogError)
{
	ns__ErrorLog *_p = soap_new_ns__ErrorLog(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__ErrorLog::errorLogDateTime = errorLogDateTime;
		_p->ns__ErrorLog::errorLogDevice = errorLogDevice;
		_p->ns__ErrorLog::errorLogType = errorLogType;
		_p->ns__ErrorLog::errorLogError = errorLogError;
	}
	return _p;
}

inline int soap_write_ns__ErrorLog(struct soap *soap, ns__ErrorLog const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:ErrorLog", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__ErrorLog * SOAP_FMAC4 soap_get_ns__ErrorLog(struct soap*, ns__ErrorLog *, const char*, const char*);

inline int soap_read_ns__ErrorLog(struct soap *soap, ns__ErrorLog *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__ErrorLog(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__DeviceStatusInfo_DEFINED
#define SOAP_TYPE_ns__DeviceStatusInfo_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceStatusInfo(struct soap*, const char*, int, const ns__DeviceStatusInfo *, const char*);
SOAP_FMAC3 ns__DeviceStatusInfo * SOAP_FMAC4 soap_in_ns__DeviceStatusInfo(struct soap*, const char*, ns__DeviceStatusInfo *, const char*);
SOAP_FMAC1 ns__DeviceStatusInfo * SOAP_FMAC2 Server_Soap_instantiate_ns__DeviceStatusInfo(struct soap*, int, const char*, const char*, size_t*);

inline ns__DeviceStatusInfo * soap_new_ns__DeviceStatusInfo(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__DeviceStatusInfo(soap, n, NULL, NULL, NULL);
}

inline ns__DeviceStatusInfo * soap_new_req_ns__DeviceStatusInfo(
	struct soap *soap,
	const ns__ReportRange& deviceStatusInfoStartEndDateTime)
{
	ns__DeviceStatusInfo *_p = soap_new_ns__DeviceStatusInfo(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__DeviceStatusInfo::deviceStatusInfoStartEndDateTime = deviceStatusInfoStartEndDateTime;
	}
	return _p;
}

inline ns__DeviceStatusInfo * soap_new_set_ns__DeviceStatusInfo(
	struct soap *soap,
	const ns__ReportRange& deviceStatusInfoStartEndDateTime,
	const std::vector<ns__Device> & deviceStatusInfoDevice,
	const std::vector<std::string> & deviceStatusInfoErrorType)
{
	ns__DeviceStatusInfo *_p = soap_new_ns__DeviceStatusInfo(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__DeviceStatusInfo::deviceStatusInfoStartEndDateTime = deviceStatusInfoStartEndDateTime;
		_p->ns__DeviceStatusInfo::deviceStatusInfoDevice = deviceStatusInfoDevice;
		_p->ns__DeviceStatusInfo::deviceStatusInfoErrorType = deviceStatusInfoErrorType;
	}
	return _p;
}

inline int soap_write_ns__DeviceStatusInfo(struct soap *soap, ns__DeviceStatusInfo const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:DeviceStatusInfo", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__DeviceStatusInfo * SOAP_FMAC4 soap_get_ns__DeviceStatusInfo(struct soap*, ns__DeviceStatusInfo *, const char*, const char*);

inline int soap_read_ns__DeviceStatusInfo(struct soap *soap, ns__DeviceStatusInfo *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__DeviceStatusInfo(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__DeviceStatusLogList_DEFINED
#define SOAP_TYPE_ns__DeviceStatusLogList_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceStatusLogList(struct soap*, const char*, int, const ns__DeviceStatusLogList *, const char*);
SOAP_FMAC3 ns__DeviceStatusLogList * SOAP_FMAC4 soap_in_ns__DeviceStatusLogList(struct soap*, const char*, ns__DeviceStatusLogList *, const char*);
SOAP_FMAC1 ns__DeviceStatusLogList * SOAP_FMAC2 Server_Soap_instantiate_ns__DeviceStatusLogList(struct soap*, int, const char*, const char*, size_t*);

inline ns__DeviceStatusLogList * soap_new_ns__DeviceStatusLogList(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__DeviceStatusLogList(soap, n, NULL, NULL, NULL);
}

inline ns__DeviceStatusLogList * soap_new_req_ns__DeviceStatusLogList(
	struct soap *soap,
	const ns__ErrorCode& statusLogListError)
{
	ns__DeviceStatusLogList *_p = soap_new_ns__DeviceStatusLogList(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__DeviceStatusLogList::statusLogListError = statusLogListError;
	}
	return _p;
}

inline ns__DeviceStatusLogList * soap_new_set_ns__DeviceStatusLogList(
	struct soap *soap,
	const std::vector<ns__DeviceStatusLog> & statusLogListStatus,
	const ns__ErrorCode& statusLogListError)
{
	ns__DeviceStatusLogList *_p = soap_new_ns__DeviceStatusLogList(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__DeviceStatusLogList::statusLogListStatus = statusLogListStatus;
		_p->ns__DeviceStatusLogList::statusLogListError = statusLogListError;
	}
	return _p;
}

inline int soap_write_ns__DeviceStatusLogList(struct soap *soap, ns__DeviceStatusLogList const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:DeviceStatusLogList", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__DeviceStatusLogList * SOAP_FMAC4 soap_get_ns__DeviceStatusLogList(struct soap*, ns__DeviceStatusLogList *, const char*, const char*);

inline int soap_read_ns__DeviceStatusLogList(struct soap *soap, ns__DeviceStatusLogList *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__DeviceStatusLogList(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__DeviceStatusLog_DEFINED
#define SOAP_TYPE_ns__DeviceStatusLog_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceStatusLog(struct soap*, const char*, int, const ns__DeviceStatusLog *, const char*);
SOAP_FMAC3 ns__DeviceStatusLog * SOAP_FMAC4 soap_in_ns__DeviceStatusLog(struct soap*, const char*, ns__DeviceStatusLog *, const char*);
SOAP_FMAC1 ns__DeviceStatusLog * SOAP_FMAC2 Server_Soap_instantiate_ns__DeviceStatusLog(struct soap*, int, const char*, const char*, size_t*);

inline ns__DeviceStatusLog * soap_new_ns__DeviceStatusLog(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__DeviceStatusLog(soap, n, NULL, NULL, NULL);
}

inline ns__DeviceStatusLog * soap_new_req_ns__DeviceStatusLog(
	struct soap *soap,
	const ns__ReportRange& statusLogStartEndDateTime,
	const ns__Device& statusLogDevice,
	const ns__ErrorCode& statusLogError)
{
	ns__DeviceStatusLog *_p = soap_new_ns__DeviceStatusLog(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__DeviceStatusLog::statusLogStartEndDateTime = statusLogStartEndDateTime;
		_p->ns__DeviceStatusLog::statusLogDevice = statusLogDevice;
		_p->ns__DeviceStatusLog::statusLogError = statusLogError;
	}
	return _p;
}

inline ns__DeviceStatusLog * soap_new_set_ns__DeviceStatusLog(
	struct soap *soap,
	const ns__ReportRange& statusLogStartEndDateTime,
	const ns__Device& statusLogDevice,
	const ns__ErrorCode& statusLogError)
{
	ns__DeviceStatusLog *_p = soap_new_ns__DeviceStatusLog(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__DeviceStatusLog::statusLogStartEndDateTime = statusLogStartEndDateTime;
		_p->ns__DeviceStatusLog::statusLogDevice = statusLogDevice;
		_p->ns__DeviceStatusLog::statusLogError = statusLogError;
	}
	return _p;
}

inline int soap_write_ns__DeviceStatusLog(struct soap *soap, ns__DeviceStatusLog const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:DeviceStatusLog", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__DeviceStatusLog * SOAP_FMAC4 soap_get_ns__DeviceStatusLog(struct soap*, ns__DeviceStatusLog *, const char*, const char*);

inline int soap_read_ns__DeviceStatusLog(struct soap *soap, ns__DeviceStatusLog *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__DeviceStatusLog(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__UserLog_DEFINED
#define SOAP_TYPE_ns__UserLog_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UserLog(struct soap*, const char*, int, const ns__UserLog *, const char*);
SOAP_FMAC3 ns__UserLog * SOAP_FMAC4 soap_in_ns__UserLog(struct soap*, const char*, ns__UserLog *, const char*);
SOAP_FMAC1 ns__UserLog * SOAP_FMAC2 Server_Soap_instantiate_ns__UserLog(struct soap*, int, const char*, const char*, size_t*);

inline ns__UserLog * soap_new_ns__UserLog(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__UserLog(soap, n, NULL, NULL, NULL);
}

inline ns__UserLog * soap_new_req_ns__UserLog(
	struct soap *soap,
	const ns__ReportRange& userLogStartEndDateTime,
	const ns__User& userLogUser,
	const ns__ErrorCode& userLogError)
{
	ns__UserLog *_p = soap_new_ns__UserLog(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__UserLog::userLogStartEndDateTime = userLogStartEndDateTime;
		_p->ns__UserLog::userLogUser = userLogUser;
		_p->ns__UserLog::userLogError = userLogError;
	}
	return _p;
}

inline ns__UserLog * soap_new_set_ns__UserLog(
	struct soap *soap,
	const ns__ReportRange& userLogStartEndDateTime,
	const std::string& userLogData,
	const ns__User& userLogUser,
	const ns__ErrorCode& userLogError)
{
	ns__UserLog *_p = soap_new_ns__UserLog(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__UserLog::userLogStartEndDateTime = userLogStartEndDateTime;
		_p->ns__UserLog::userLogData = userLogData;
		_p->ns__UserLog::userLogUser = userLogUser;
		_p->ns__UserLog::userLogError = userLogError;
	}
	return _p;
}

inline int soap_write_ns__UserLog(struct soap *soap, ns__UserLog const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:UserLog", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__UserLog * SOAP_FMAC4 soap_get_ns__UserLog(struct soap*, ns__UserLog *, const char*, const char*);

inline int soap_read_ns__UserLog(struct soap *soap, ns__UserLog *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__UserLog(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__ActivityLog_DEFINED
#define SOAP_TYPE_ns__ActivityLog_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ActivityLog(struct soap*, const char*, int, const ns__ActivityLog *, const char*);
SOAP_FMAC3 ns__ActivityLog * SOAP_FMAC4 soap_in_ns__ActivityLog(struct soap*, const char*, ns__ActivityLog *, const char*);
SOAP_FMAC1 ns__ActivityLog * SOAP_FMAC2 Server_Soap_instantiate_ns__ActivityLog(struct soap*, int, const char*, const char*, size_t*);

inline ns__ActivityLog * soap_new_ns__ActivityLog(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__ActivityLog(soap, n, NULL, NULL, NULL);
}

inline ns__ActivityLog * soap_new_req_ns__ActivityLog(
	struct soap *soap,
	const ns__ReportRange& activityLogStartEndDateTime,
	const ns__Device& activityLogDevice,
	const ns__User& activityLogUser,
	const ns__ErrorCode& activityError)
{
	ns__ActivityLog *_p = soap_new_ns__ActivityLog(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__ActivityLog::activityLogStartEndDateTime = activityLogStartEndDateTime;
		_p->ns__ActivityLog::activityLogDevice = activityLogDevice;
		_p->ns__ActivityLog::activityLogUser = activityLogUser;
		_p->ns__ActivityLog::activityError = activityError;
	}
	return _p;
}

inline ns__ActivityLog * soap_new_set_ns__ActivityLog(
	struct soap *soap,
	const ns__ReportRange& activityLogStartEndDateTime,
	const std::string& activityLogData,
	const ns__Device& activityLogDevice,
	const ns__User& activityLogUser,
	const ns__ErrorCode& activityError)
{
	ns__ActivityLog *_p = soap_new_ns__ActivityLog(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__ActivityLog::activityLogStartEndDateTime = activityLogStartEndDateTime;
		_p->ns__ActivityLog::activityLogData = activityLogData;
		_p->ns__ActivityLog::activityLogDevice = activityLogDevice;
		_p->ns__ActivityLog::activityLogUser = activityLogUser;
		_p->ns__ActivityLog::activityError = activityError;
	}
	return _p;
}

inline int soap_write_ns__ActivityLog(struct soap *soap, ns__ActivityLog const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:ActivityLog", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__ActivityLog * SOAP_FMAC4 soap_get_ns__ActivityLog(struct soap*, ns__ActivityLog *, const char*, const char*);

inline int soap_read_ns__ActivityLog(struct soap *soap, ns__ActivityLog *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__ActivityLog(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__ReportRange_DEFINED
#define SOAP_TYPE_ns__ReportRange_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ReportRange(struct soap*, const char*, int, const ns__ReportRange *, const char*);
SOAP_FMAC3 ns__ReportRange * SOAP_FMAC4 soap_in_ns__ReportRange(struct soap*, const char*, ns__ReportRange *, const char*);
SOAP_FMAC1 ns__ReportRange * SOAP_FMAC2 Server_Soap_instantiate_ns__ReportRange(struct soap*, int, const char*, const char*, size_t*);

inline ns__ReportRange * soap_new_ns__ReportRange(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__ReportRange(soap, n, NULL, NULL, NULL);
}

inline ns__ReportRange * soap_new_req_ns__ReportRange(
	struct soap *soap,
	time_t reportStartDate,
	time_t reportEndDate)
{
	ns__ReportRange *_p = soap_new_ns__ReportRange(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__ReportRange::reportStartDate = reportStartDate;
		_p->ns__ReportRange::reportEndDate = reportEndDate;
	}
	return _p;
}

inline ns__ReportRange * soap_new_set_ns__ReportRange(
	struct soap *soap,
	time_t reportStartDate,
	time_t reportEndDate)
{
	ns__ReportRange *_p = soap_new_ns__ReportRange(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__ReportRange::reportStartDate = reportStartDate;
		_p->ns__ReportRange::reportEndDate = reportEndDate;
	}
	return _p;
}

inline int soap_write_ns__ReportRange(struct soap *soap, ns__ReportRange const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:ReportRange", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__ReportRange * SOAP_FMAC4 soap_get_ns__ReportRange(struct soap*, ns__ReportRange *, const char*, const char*);

inline int soap_read_ns__ReportRange(struct soap *soap, ns__ReportRange *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__ReportRange(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__Device_DEFINED
#define SOAP_TYPE_ns__Device_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Device(struct soap*, const char*, int, const ns__Device *, const char*);
SOAP_FMAC3 ns__Device * SOAP_FMAC4 soap_in_ns__Device(struct soap*, const char*, ns__Device *, const char*);
SOAP_FMAC1 ns__Device * SOAP_FMAC2 Server_Soap_instantiate_ns__Device(struct soap*, int, const char*, const char*, size_t*);

inline ns__Device * soap_new_ns__Device(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__Device(soap, n, NULL, NULL, NULL);
}

inline ns__Device * soap_new_req_ns__Device(
	struct soap *soap,
	const std::string& deviceDNSAddress,
	const ns__IP& deviceIP,
	time_t deviceDateTime,
	const ns__Mobile& deviceMobileInfo,
	const ns__Server& deviceServerInfo,
	const ns__Camera& deviceCameraInfo,
	const ns__Gprs& deviceGprsInfo,
	const ns__Picture& devicePicture,
	const ns__ErrorCode& deviceError,
	const ns__GPS& deviceGPS)
{
	ns__Device *_p = soap_new_ns__Device(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__Device::deviceDNSAddress = deviceDNSAddress;
		_p->ns__Device::deviceIP = deviceIP;
		_p->ns__Device::deviceDateTime = deviceDateTime;
		_p->ns__Device::deviceMobileInfo = deviceMobileInfo;
		_p->ns__Device::deviceServerInfo = deviceServerInfo;
		_p->ns__Device::deviceCameraInfo = deviceCameraInfo;
		_p->ns__Device::deviceGprsInfo = deviceGprsInfo;
		_p->ns__Device::devicePicture = devicePicture;
		_p->ns__Device::deviceError = deviceError;
		_p->ns__Device::deviceGPS = deviceGPS;
	}
	return _p;
}

inline ns__Device * soap_new_set_ns__Device(
	struct soap *soap,
	int deviceSerialNumber,
	enum ns__DeviceModel deviceModel,
	const std::string& deviceName,
	const std::string& deviceFirmWareVersion,
	const std::string& deviceNikeName,
	const std::string& deviceLocation,
	const std::string& deviceCity,
	int deviceSocket,
	const std::string& deviceDNSAddress,
	const ns__IP& deviceIP,
	int devicePort,
	time_t deviceDateTime,
	const ns__Mobile& deviceMobileInfo,
	const ns__Server& deviceServerInfo,
	const ns__Camera& deviceCameraInfo,
	const ns__Gprs& deviceGprsInfo,
	const std::vector<LONG64> & deviceSMSContact,
	const std::vector<LONG64> & deviceSMSConfig,
	const std::string& deviceFlags,
	bool deviceSMSCommand,
	bool deviceGSMCommand,
	bool deviceKeyBoardCommand,
	bool deviceBuzzerOnOff,
	bool deviceReset,
	int deviceSamplingTime,
	const ns__Picture& devicePicture,
	const std::vector<bool> & deviceRelays,
	const std::vector<ns__Request> & deviceRequests,
	const std::vector<ns__SensorExtension> & deviceSensors,
	const ns__ErrorCode& deviceError,
	int deviceTransPower,
	int deviceTableCapacity,
	const ns__GPS& deviceGPS,
	const std::string& deviceKeyType)
{
	ns__Device *_p = soap_new_ns__Device(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__Device::deviceSerialNumber = deviceSerialNumber;
		_p->ns__Device::deviceModel = deviceModel;
		_p->ns__Device::deviceName = deviceName;
		_p->ns__Device::deviceFirmWareVersion = deviceFirmWareVersion;
		_p->ns__Device::deviceNikeName = deviceNikeName;
		_p->ns__Device::deviceLocation = deviceLocation;
		_p->ns__Device::deviceCity = deviceCity;
		_p->ns__Device::deviceSocket = deviceSocket;
		_p->ns__Device::deviceDNSAddress = deviceDNSAddress;
		_p->ns__Device::deviceIP = deviceIP;
		_p->ns__Device::devicePort = devicePort;
		_p->ns__Device::deviceDateTime = deviceDateTime;
		_p->ns__Device::deviceMobileInfo = deviceMobileInfo;
		_p->ns__Device::deviceServerInfo = deviceServerInfo;
		_p->ns__Device::deviceCameraInfo = deviceCameraInfo;
		_p->ns__Device::deviceGprsInfo = deviceGprsInfo;
		_p->ns__Device::deviceSMSContact = deviceSMSContact;
		_p->ns__Device::deviceSMSConfig = deviceSMSConfig;
		_p->ns__Device::deviceFlags = deviceFlags;
		_p->ns__Device::deviceSMSCommand = deviceSMSCommand;
		_p->ns__Device::deviceGSMCommand = deviceGSMCommand;
		_p->ns__Device::deviceKeyBoardCommand = deviceKeyBoardCommand;
		_p->ns__Device::deviceBuzzerOnOff = deviceBuzzerOnOff;
		_p->ns__Device::deviceReset = deviceReset;
		_p->ns__Device::deviceSamplingTime = deviceSamplingTime;
		_p->ns__Device::devicePicture = devicePicture;
		_p->ns__Device::deviceRelays = deviceRelays;
		_p->ns__Device::deviceRequests = deviceRequests;
		_p->ns__Device::deviceSensors = deviceSensors;
		_p->ns__Device::deviceError = deviceError;
		_p->ns__Device::deviceTransPower = deviceTransPower;
		_p->ns__Device::deviceTableCapacity = deviceTableCapacity;
		_p->ns__Device::deviceGPS = deviceGPS;
		_p->ns__Device::deviceKeyType = deviceKeyType;
	}
	return _p;
}

inline int soap_write_ns__Device(struct soap *soap, ns__Device const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:Device", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__Device * SOAP_FMAC4 soap_get_ns__Device(struct soap*, ns__Device *, const char*, const char*);

inline int soap_read_ns__Device(struct soap *soap, ns__Device *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__Device(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__Request_DEFINED
#define SOAP_TYPE_ns__Request_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Request(struct soap*, const char*, int, const ns__Request *, const char*);
SOAP_FMAC3 ns__Request * SOAP_FMAC4 soap_in_ns__Request(struct soap*, const char*, ns__Request *, const char*);
SOAP_FMAC1 ns__Request * SOAP_FMAC2 Server_Soap_instantiate_ns__Request(struct soap*, int, const char*, const char*, size_t*);

inline ns__Request * soap_new_ns__Request(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__Request(soap, n, NULL, NULL, NULL);
}

inline ns__Request * soap_new_req_ns__Request(
	struct soap *soap)
{
	ns__Request *_p = soap_new_ns__Request(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline ns__Request * soap_new_set_ns__Request(
	struct soap *soap,
	enum ns__RequestType requestRequestType)
{
	ns__Request *_p = soap_new_ns__Request(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__Request::requestRequestType = requestRequestType;
	}
	return _p;
}

inline int soap_write_ns__Request(struct soap *soap, ns__Request const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:Request", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__Request * SOAP_FMAC4 soap_get_ns__Request(struct soap*, ns__Request *, const char*, const char*);

inline int soap_read_ns__Request(struct soap *soap, ns__Request *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__Request(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__Picture_DEFINED
#define SOAP_TYPE_ns__Picture_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Picture(struct soap*, const char*, int, const ns__Picture *, const char*);
SOAP_FMAC3 ns__Picture * SOAP_FMAC4 soap_in_ns__Picture(struct soap*, const char*, ns__Picture *, const char*);
SOAP_FMAC1 ns__Picture * SOAP_FMAC2 Server_Soap_instantiate_ns__Picture(struct soap*, int, const char*, const char*, size_t*);

inline ns__Picture * soap_new_ns__Picture(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__Picture(soap, n, NULL, NULL, NULL);
}

inline ns__Picture * soap_new_req_ns__Picture(
	struct soap *soap)
{
	ns__Picture *_p = soap_new_ns__Picture(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline ns__Picture * soap_new_set_ns__Picture(
	struct soap *soap,
	int pictureSize,
	int picturePartSize,
	int picturePartNumbers,
	int pictureCRC,
	const std::vector<ns__PicturePart> & pictureParts)
{
	ns__Picture *_p = soap_new_ns__Picture(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__Picture::pictureSize = pictureSize;
		_p->ns__Picture::picturePartSize = picturePartSize;
		_p->ns__Picture::picturePartNumbers = picturePartNumbers;
		_p->ns__Picture::pictureCRC = pictureCRC;
		_p->ns__Picture::pictureParts = pictureParts;
	}
	return _p;
}

inline int soap_write_ns__Picture(struct soap *soap, ns__Picture const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:Picture", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__Picture * SOAP_FMAC4 soap_get_ns__Picture(struct soap*, ns__Picture *, const char*, const char*);

inline int soap_read_ns__Picture(struct soap *soap, ns__Picture *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__Picture(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__PicturePart_DEFINED
#define SOAP_TYPE_ns__PicturePart_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__PicturePart(struct soap*, const char*, int, const ns__PicturePart *, const char*);
SOAP_FMAC3 ns__PicturePart * SOAP_FMAC4 soap_in_ns__PicturePart(struct soap*, const char*, ns__PicturePart *, const char*);
SOAP_FMAC1 ns__PicturePart * SOAP_FMAC2 Server_Soap_instantiate_ns__PicturePart(struct soap*, int, const char*, const char*, size_t*);

inline ns__PicturePart * soap_new_ns__PicturePart(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__PicturePart(soap, n, NULL, NULL, NULL);
}

inline ns__PicturePart * soap_new_req_ns__PicturePart(
	struct soap *soap,
	int partIndex,
	const std::string& partData,
	int partCRC)
{
	ns__PicturePart *_p = soap_new_ns__PicturePart(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__PicturePart::partIndex = partIndex;
		_p->ns__PicturePart::partData = partData;
		_p->ns__PicturePart::partCRC = partCRC;
	}
	return _p;
}

inline ns__PicturePart * soap_new_set_ns__PicturePart(
	struct soap *soap,
	int partIndex,
	const std::string& partData,
	int partCRC)
{
	ns__PicturePart *_p = soap_new_ns__PicturePart(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__PicturePart::partIndex = partIndex;
		_p->ns__PicturePart::partData = partData;
		_p->ns__PicturePart::partCRC = partCRC;
	}
	return _p;
}

inline int soap_write_ns__PicturePart(struct soap *soap, ns__PicturePart const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:PicturePart", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__PicturePart * SOAP_FMAC4 soap_get_ns__PicturePart(struct soap*, ns__PicturePart *, const char*, const char*);

inline int soap_read_ns__PicturePart(struct soap *soap, ns__PicturePart *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__PicturePart(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__Camera_DEFINED
#define SOAP_TYPE_ns__Camera_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Camera(struct soap*, const char*, int, const ns__Camera *, const char*);
SOAP_FMAC3 ns__Camera * SOAP_FMAC4 soap_in_ns__Camera(struct soap*, const char*, ns__Camera *, const char*);
SOAP_FMAC1 ns__Camera * SOAP_FMAC2 Server_Soap_instantiate_ns__Camera(struct soap*, int, const char*, const char*, size_t*);

inline ns__Camera * soap_new_ns__Camera(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__Camera(soap, n, NULL, NULL, NULL);
}

inline ns__Camera * soap_new_req_ns__Camera(
	struct soap *soap,
	const ns__IP& cameraIP,
	const ns__ErrorCode& cameraError)
{
	ns__Camera *_p = soap_new_ns__Camera(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__Camera::cameraIP = cameraIP;
		_p->ns__Camera::cameraError = cameraError;
	}
	return _p;
}

inline ns__Camera * soap_new_set_ns__Camera(
	struct soap *soap,
	const std::string& cameraName,
	int cameraSocket,
	const ns__IP& cameraIP,
	int cameraPort,
	const ns__ErrorCode& cameraError)
{
	ns__Camera *_p = soap_new_ns__Camera(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__Camera::cameraName = cameraName;
		_p->ns__Camera::cameraSocket = cameraSocket;
		_p->ns__Camera::cameraIP = cameraIP;
		_p->ns__Camera::cameraPort = cameraPort;
		_p->ns__Camera::cameraError = cameraError;
	}
	return _p;
}

inline int soap_write_ns__Camera(struct soap *soap, ns__Camera const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:Camera", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__Camera * SOAP_FMAC4 soap_get_ns__Camera(struct soap*, ns__Camera *, const char*, const char*);

inline int soap_read_ns__Camera(struct soap *soap, ns__Camera *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__Camera(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__SensorExtension_DEFINED
#define SOAP_TYPE_ns__SensorExtension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SensorExtension(struct soap*, const char*, int, const ns__SensorExtension *, const char*);
SOAP_FMAC3 ns__SensorExtension * SOAP_FMAC4 soap_in_ns__SensorExtension(struct soap*, const char*, ns__SensorExtension *, const char*);
SOAP_FMAC1 ns__SensorExtension * SOAP_FMAC2 Server_Soap_instantiate_ns__SensorExtension(struct soap*, int, const char*, const char*, size_t*);

inline ns__SensorExtension * soap_new_ns__SensorExtension(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__SensorExtension(soap, n, NULL, NULL, NULL);
}

inline ns__SensorExtension * soap_new_req_ns__SensorExtension(
	struct soap *soap)
{
	ns__SensorExtension *_p = soap_new_ns__SensorExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline ns__SensorExtension * soap_new_set_ns__SensorExtension(
	struct soap *soap,
	enum ns__SensorName sensorName,
	const std::vector<ns__Sensor> & deviceSensors)
{
	ns__SensorExtension *_p = soap_new_ns__SensorExtension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__SensorExtension::sensorName = sensorName;
		_p->ns__SensorExtension::deviceSensors = deviceSensors;
	}
	return _p;
}

inline int soap_write_ns__SensorExtension(struct soap *soap, ns__SensorExtension const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:SensorExtension", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__SensorExtension * SOAP_FMAC4 soap_get_ns__SensorExtension(struct soap*, ns__SensorExtension *, const char*, const char*);

inline int soap_read_ns__SensorExtension(struct soap *soap, ns__SensorExtension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__SensorExtension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__Sensor_DEFINED
#define SOAP_TYPE_ns__Sensor_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Sensor(struct soap*, const char*, int, const ns__Sensor *, const char*);
SOAP_FMAC3 ns__Sensor * SOAP_FMAC4 soap_in_ns__Sensor(struct soap*, const char*, ns__Sensor *, const char*);
SOAP_FMAC1 ns__Sensor * SOAP_FMAC2 Server_Soap_instantiate_ns__Sensor(struct soap*, int, const char*, const char*, size_t*);

inline ns__Sensor * soap_new_ns__Sensor(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__Sensor(soap, n, NULL, NULL, NULL);
}

inline ns__Sensor * soap_new_req_ns__Sensor(
	struct soap *soap,
	const ns__Relay& sensorRelay,
	const ns__ErrorCode& sensorError)
{
	ns__Sensor *_p = soap_new_ns__Sensor(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__Sensor::sensorRelay = sensorRelay;
		_p->ns__Sensor::sensorError = sensorError;
	}
	return _p;
}

inline ns__Sensor * soap_new_set_ns__Sensor(
	struct soap *soap,
	const std::string& sensorNikeName,
	double sensorValue,
	int sensorCalibration,
	int sensorMinimumValue,
	int sensorMaximumValue,
	int sensorMaximumThreshold,
	int sensorMinimumThreshold,
	bool sensorSMSOnOff,
	bool sensorBuzzerOnOff,
	const ns__Relay& sensorRelay,
	bool sensorLEDFlag,
	enum ns__SensorType sensorType,
	const ns__ErrorCode& sensorError)
{
	ns__Sensor *_p = soap_new_ns__Sensor(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__Sensor::sensorNikeName = sensorNikeName;
		_p->ns__Sensor::sensorValue = sensorValue;
		_p->ns__Sensor::sensorCalibration = sensorCalibration;
		_p->ns__Sensor::sensorMinimumValue = sensorMinimumValue;
		_p->ns__Sensor::sensorMaximumValue = sensorMaximumValue;
		_p->ns__Sensor::sensorMaximumThreshold = sensorMaximumThreshold;
		_p->ns__Sensor::sensorMinimumThreshold = sensorMinimumThreshold;
		_p->ns__Sensor::sensorSMSOnOff = sensorSMSOnOff;
		_p->ns__Sensor::sensorBuzzerOnOff = sensorBuzzerOnOff;
		_p->ns__Sensor::sensorRelay = sensorRelay;
		_p->ns__Sensor::sensorLEDFlag = sensorLEDFlag;
		_p->ns__Sensor::sensorType = sensorType;
		_p->ns__Sensor::sensorError = sensorError;
	}
	return _p;
}

inline int soap_write_ns__Sensor(struct soap *soap, ns__Sensor const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:Sensor", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__Sensor * SOAP_FMAC4 soap_get_ns__Sensor(struct soap*, ns__Sensor *, const char*, const char*);

inline int soap_read_ns__Sensor(struct soap *soap, ns__Sensor *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__Sensor(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__Relay_DEFINED
#define SOAP_TYPE_ns__Relay_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Relay(struct soap*, const char*, int, const ns__Relay *, const char*);
SOAP_FMAC3 ns__Relay * SOAP_FMAC4 soap_in_ns__Relay(struct soap*, const char*, ns__Relay *, const char*);
SOAP_FMAC1 ns__Relay * SOAP_FMAC2 Server_Soap_instantiate_ns__Relay(struct soap*, int, const char*, const char*, size_t*);

inline ns__Relay * soap_new_ns__Relay(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__Relay(soap, n, NULL, NULL, NULL);
}

inline ns__Relay * soap_new_req_ns__Relay(
	struct soap *soap)
{
	ns__Relay *_p = soap_new_ns__Relay(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline ns__Relay * soap_new_set_ns__Relay(
	struct soap *soap,
	int relayIndex,
	bool relayOnOff)
{
	ns__Relay *_p = soap_new_ns__Relay(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__Relay::relayIndex = relayIndex;
		_p->ns__Relay::relayOnOff = relayOnOff;
	}
	return _p;
}

inline int soap_write_ns__Relay(struct soap *soap, ns__Relay const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:Relay", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__Relay * SOAP_FMAC4 soap_get_ns__Relay(struct soap*, ns__Relay *, const char*, const char*);

inline int soap_read_ns__Relay(struct soap *soap, ns__Relay *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__Relay(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__Mobile_DEFINED
#define SOAP_TYPE_ns__Mobile_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Mobile(struct soap*, const char*, int, const ns__Mobile *, const char*);
SOAP_FMAC3 ns__Mobile * SOAP_FMAC4 soap_in_ns__Mobile(struct soap*, const char*, ns__Mobile *, const char*);
SOAP_FMAC1 ns__Mobile * SOAP_FMAC2 Server_Soap_instantiate_ns__Mobile(struct soap*, int, const char*, const char*, size_t*);

inline ns__Mobile * soap_new_ns__Mobile(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__Mobile(soap, n, NULL, NULL, NULL);
}

inline ns__Mobile * soap_new_req_ns__Mobile(
	struct soap *soap)
{
	ns__Mobile *_p = soap_new_ns__Mobile(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline ns__Mobile * soap_new_set_ns__Mobile(
	struct soap *soap,
	LONG64 mobileNumber,
	enum ns__SimcardType mobileSimCardType,
	int mobileChargeValue,
	int mobileSignalValue)
{
	ns__Mobile *_p = soap_new_ns__Mobile(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__Mobile::mobileNumber = mobileNumber;
		_p->ns__Mobile::mobileSimCardType = mobileSimCardType;
		_p->ns__Mobile::mobileChargeValue = mobileChargeValue;
		_p->ns__Mobile::mobileSignalValue = mobileSignalValue;
	}
	return _p;
}

inline int soap_write_ns__Mobile(struct soap *soap, ns__Mobile const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:Mobile", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__Mobile * SOAP_FMAC4 soap_get_ns__Mobile(struct soap*, ns__Mobile *, const char*, const char*);

inline int soap_read_ns__Mobile(struct soap *soap, ns__Mobile *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__Mobile(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__GPS_DEFINED
#define SOAP_TYPE_ns__GPS_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GPS(struct soap*, const char*, int, const ns__GPS *, const char*);
SOAP_FMAC3 ns__GPS * SOAP_FMAC4 soap_in_ns__GPS(struct soap*, const char*, ns__GPS *, const char*);
SOAP_FMAC1 ns__GPS * SOAP_FMAC2 Server_Soap_instantiate_ns__GPS(struct soap*, int, const char*, const char*, size_t*);

inline ns__GPS * soap_new_ns__GPS(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__GPS(soap, n, NULL, NULL, NULL);
}

inline ns__GPS * soap_new_req_ns__GPS(
	struct soap *soap)
{
	ns__GPS *_p = soap_new_ns__GPS(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline ns__GPS * soap_new_set_ns__GPS(
	struct soap *soap,
	double gpsX,
	double gpsY)
{
	ns__GPS *_p = soap_new_ns__GPS(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__GPS::gpsX = gpsX;
		_p->ns__GPS::gpsY = gpsY;
	}
	return _p;
}

inline int soap_write_ns__GPS(struct soap *soap, ns__GPS const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:GPS", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__GPS * SOAP_FMAC4 soap_get_ns__GPS(struct soap*, ns__GPS *, const char*, const char*);

inline int soap_read_ns__GPS(struct soap *soap, ns__GPS *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__GPS(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__Gprs_DEFINED
#define SOAP_TYPE_ns__Gprs_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Gprs(struct soap*, const char*, int, const ns__Gprs *, const char*);
SOAP_FMAC3 ns__Gprs * SOAP_FMAC4 soap_in_ns__Gprs(struct soap*, const char*, ns__Gprs *, const char*);
SOAP_FMAC1 ns__Gprs * SOAP_FMAC2 Server_Soap_instantiate_ns__Gprs(struct soap*, int, const char*, const char*, size_t*);

inline ns__Gprs * soap_new_ns__Gprs(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__Gprs(soap, n, NULL, NULL, NULL);
}

inline ns__Gprs * soap_new_req_ns__Gprs(
	struct soap *soap,
	const std::string& gprsDNSAddress,
	const ns__IP& gprsIP,
	const ns__ErrorCode& gprsError)
{
	ns__Gprs *_p = soap_new_ns__Gprs(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__Gprs::gprsDNSAddress = gprsDNSAddress;
		_p->ns__Gprs::gprsIP = gprsIP;
		_p->ns__Gprs::gprsError = gprsError;
	}
	return _p;
}

inline ns__Gprs * soap_new_set_ns__Gprs(
	struct soap *soap,
	const std::string& gprsDNSAddress,
	const ns__IP& gprsIP,
	int gprsPort,
	const ns__ErrorCode& gprsError)
{
	ns__Gprs *_p = soap_new_ns__Gprs(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__Gprs::gprsDNSAddress = gprsDNSAddress;
		_p->ns__Gprs::gprsIP = gprsIP;
		_p->ns__Gprs::gprsPort = gprsPort;
		_p->ns__Gprs::gprsError = gprsError;
	}
	return _p;
}

inline int soap_write_ns__Gprs(struct soap *soap, ns__Gprs const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:Gprs", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__Gprs * SOAP_FMAC4 soap_get_ns__Gprs(struct soap*, ns__Gprs *, const char*, const char*);

inline int soap_read_ns__Gprs(struct soap *soap, ns__Gprs *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__Gprs(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__Server_DEFINED
#define SOAP_TYPE_ns__Server_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Server(struct soap*, const char*, int, const ns__Server *, const char*);
SOAP_FMAC3 ns__Server * SOAP_FMAC4 soap_in_ns__Server(struct soap*, const char*, ns__Server *, const char*);
SOAP_FMAC1 ns__Server * SOAP_FMAC2 Server_Soap_instantiate_ns__Server(struct soap*, int, const char*, const char*, size_t*);

inline ns__Server * soap_new_ns__Server(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__Server(soap, n, NULL, NULL, NULL);
}

inline ns__Server * soap_new_req_ns__Server(
	struct soap *soap,
	const std::string& serverDNSAddress,
	const ns__IP& serverIP,
	const ns__ErrorCode& serverError)
{
	ns__Server *_p = soap_new_ns__Server(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__Server::serverDNSAddress = serverDNSAddress;
		_p->ns__Server::serverIP = serverIP;
		_p->ns__Server::serverError = serverError;
	}
	return _p;
}

inline ns__Server * soap_new_set_ns__Server(
	struct soap *soap,
	const std::string& serverDNSAddress,
	const ns__IP& serverIP,
	int serverPort,
	const ns__ErrorCode& serverError)
{
	ns__Server *_p = soap_new_ns__Server(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__Server::serverDNSAddress = serverDNSAddress;
		_p->ns__Server::serverIP = serverIP;
		_p->ns__Server::serverPort = serverPort;
		_p->ns__Server::serverError = serverError;
	}
	return _p;
}

inline int soap_write_ns__Server(struct soap *soap, ns__Server const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:Server", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__Server * SOAP_FMAC4 soap_get_ns__Server(struct soap*, ns__Server *, const char*, const char*);

inline int soap_read_ns__Server(struct soap *soap, ns__Server *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__Server(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__IP_DEFINED
#define SOAP_TYPE_ns__IP_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__IP(struct soap*, const char*, int, const ns__IP *, const char*);
SOAP_FMAC3 ns__IP * SOAP_FMAC4 soap_in_ns__IP(struct soap*, const char*, ns__IP *, const char*);
SOAP_FMAC1 ns__IP * SOAP_FMAC2 Server_Soap_instantiate_ns__IP(struct soap*, int, const char*, const char*, size_t*);

inline ns__IP * soap_new_ns__IP(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__IP(soap, n, NULL, NULL, NULL);
}

inline ns__IP * soap_new_req_ns__IP(
	struct soap *soap)
{
	ns__IP *_p = soap_new_ns__IP(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline ns__IP * soap_new_set_ns__IP(
	struct soap *soap,
	int ip1,
	int ip2,
	int ip3,
	int ip4)
{
	ns__IP *_p = soap_new_ns__IP(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__IP::ip1 = ip1;
		_p->ns__IP::ip2 = ip2;
		_p->ns__IP::ip3 = ip3;
		_p->ns__IP::ip4 = ip4;
	}
	return _p;
}

inline int soap_write_ns__IP(struct soap *soap, ns__IP const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:IP", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__IP * SOAP_FMAC4 soap_get_ns__IP(struct soap*, ns__IP *, const char*, const char*);

inline int soap_read_ns__IP(struct soap *soap, ns__IP *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__IP(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__UsersList_DEFINED
#define SOAP_TYPE_ns__UsersList_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UsersList(struct soap*, const char*, int, const ns__UsersList *, const char*);
SOAP_FMAC3 ns__UsersList * SOAP_FMAC4 soap_in_ns__UsersList(struct soap*, const char*, ns__UsersList *, const char*);
SOAP_FMAC1 ns__UsersList * SOAP_FMAC2 Server_Soap_instantiate_ns__UsersList(struct soap*, int, const char*, const char*, size_t*);

inline ns__UsersList * soap_new_ns__UsersList(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__UsersList(soap, n, NULL, NULL, NULL);
}

inline ns__UsersList * soap_new_req_ns__UsersList(
	struct soap *soap,
	const ns__ErrorCode& usersListError)
{
	ns__UsersList *_p = soap_new_ns__UsersList(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__UsersList::usersListError = usersListError;
	}
	return _p;
}

inline ns__UsersList * soap_new_set_ns__UsersList(
	struct soap *soap,
	const std::vector<ns__User> & usersListUsers,
	const ns__ErrorCode& usersListError)
{
	ns__UsersList *_p = soap_new_ns__UsersList(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__UsersList::usersListUsers = usersListUsers;
		_p->ns__UsersList::usersListError = usersListError;
	}
	return _p;
}

inline int soap_write_ns__UsersList(struct soap *soap, ns__UsersList const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:UsersList", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__UsersList * SOAP_FMAC4 soap_get_ns__UsersList(struct soap*, ns__UsersList *, const char*, const char*);

inline int soap_read_ns__UsersList(struct soap *soap, ns__UsersList *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__UsersList(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__User_DEFINED
#define SOAP_TYPE_ns__User_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__User(struct soap*, const char*, int, const ns__User *, const char*);
SOAP_FMAC3 ns__User * SOAP_FMAC4 soap_in_ns__User(struct soap*, const char*, ns__User *, const char*);
SOAP_FMAC1 ns__User * SOAP_FMAC2 Server_Soap_instantiate_ns__User(struct soap*, int, const char*, const char*, size_t*);

inline ns__User * soap_new_ns__User(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__User(soap, n, NULL, NULL, NULL);
}

inline ns__User * soap_new_req_ns__User(
	struct soap *soap,
	time_t userSubmit,
	const ns__ErrorCode& userError)
{
	ns__User *_p = soap_new_ns__User(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__User::userSubmit = userSubmit;
		_p->ns__User::userError = userError;
	}
	return _p;
}

inline ns__User * soap_new_set_ns__User(
	struct soap *soap,
	int userId,
	const std::string& userName,
	const std::string& userPassword,
	const std::string& userNewPassword,
	const std::string& userFirstName,
	const std::string& userLastName,
	enum ns__UserType userType,
	const std::string& userKey,
	time_t userSubmit,
	const ns__ErrorCode& userError)
{
	ns__User *_p = soap_new_ns__User(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__User::userId = userId;
		_p->ns__User::userName = userName;
		_p->ns__User::userPassword = userPassword;
		_p->ns__User::userNewPassword = userNewPassword;
		_p->ns__User::userFirstName = userFirstName;
		_p->ns__User::userLastName = userLastName;
		_p->ns__User::userType = userType;
		_p->ns__User::userKey = userKey;
		_p->ns__User::userSubmit = userSubmit;
		_p->ns__User::userError = userError;
	}
	return _p;
}

inline int soap_write_ns__User(struct soap *soap, ns__User const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:User", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__User * SOAP_FMAC4 soap_get_ns__User(struct soap*, ns__User *, const char*, const char*);

inline int soap_read_ns__User(struct soap *soap, ns__User *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__User(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__ErrorCode_DEFINED
#define SOAP_TYPE_ns__ErrorCode_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ErrorCode(struct soap*, const char*, int, const ns__ErrorCode *, const char*);
SOAP_FMAC3 ns__ErrorCode * SOAP_FMAC4 soap_in_ns__ErrorCode(struct soap*, const char*, ns__ErrorCode *, const char*);
SOAP_FMAC1 ns__ErrorCode * SOAP_FMAC2 Server_Soap_instantiate_ns__ErrorCode(struct soap*, int, const char*, const char*, size_t*);

inline ns__ErrorCode * soap_new_ns__ErrorCode(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__ErrorCode(soap, n, NULL, NULL, NULL);
}

inline ns__ErrorCode * soap_new_req_ns__ErrorCode(
	struct soap *soap)
{
	ns__ErrorCode *_p = soap_new_ns__ErrorCode(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline ns__ErrorCode * soap_new_set_ns__ErrorCode(
	struct soap *soap,
	int errorNumber,
	const std::string& errorMessage,
	enum ns__SettingLevel errorType)
{
	ns__ErrorCode *_p = soap_new_ns__ErrorCode(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->ns__ErrorCode::errorNumber = errorNumber;
		_p->ns__ErrorCode::errorMessage = errorMessage;
		_p->ns__ErrorCode::errorType = errorType;
	}
	return _p;
}

inline int soap_write_ns__ErrorCode(struct soap *soap, ns__ErrorCode const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns:ErrorCode", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 ns__ErrorCode * SOAP_FMAC4 soap_get_ns__ErrorCode(struct soap*, ns__ErrorCode *, const char*, const char*);

inline int soap_read_ns__ErrorCode(struct soap *soap, ns__ErrorCode *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_ns__ErrorCode(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__string_DEFINED
#define SOAP_TYPE_xsd__string_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__string(struct soap*, std::string *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__string(struct soap*, const std::string *);

#define soap_xsd__string2s soap_std__string2s

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__string soap_s2std__string

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__string(struct soap*, const char*, std::string*, const char*);

#define Server_Soap_instantiate_xsd__string Server_Soap_instantiate_std__string


#define soap_new_xsd__string soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__string(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__string(struct soap *soap, std::string const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__string(soap, p, "xsd:string", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__string(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__string(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__string(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_std__string_DEFINED
#define SOAP_TYPE_std__string_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap*, std::string *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap*, const std::string *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap*, const char*, int, const std::string*, const char*);
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap*, const char*, std::string*, const char*);
SOAP_FMAC1 std::string * SOAP_FMAC2 Server_Soap_instantiate_std__string(struct soap*, int, const char*, const char*, size_t*);

inline std::string * soap_new_std__string(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

inline std::string * soap_new_req_std__string(
	struct soap *soap)
{
	std::string *_p = soap_new_std__string(soap);
	if (_p)
	{	soap_default_std__string(soap, _p);
	}
	return _p;
}

inline std::string * soap_new_set_std__string(
	struct soap *soap)
{
	std::string *_p = soap_new_std__string(soap);
	if (_p)
	{	soap_default_std__string(soap, _p);
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_std__string(struct soap *soap, std::string const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_std__string(soap, p, "string", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap*, std::string *, const char*, const char*);

inline int soap_read_std__string(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_std__string(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault_DEFINED
#define SOAP_TYPE_SOAP_ENV__Fault_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap*, const char*, int, const struct SOAP_ENV__Fault *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap*, const char*, struct SOAP_ENV__Fault *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 Server_Soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Fault * soap_new_SOAP_ENV__Fault(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Fault * soap_new_req_SOAP_ENV__Fault(
	struct soap *soap)
{
	struct SOAP_ENV__Fault *_p = soap_new_SOAP_ENV__Fault(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Fault(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Fault * soap_new_set_SOAP_ENV__Fault(
	struct soap *soap,
	char *faultcode,
	char *faultstring,
	char *faultactor,
	struct SOAP_ENV__Detail *detail,
	struct SOAP_ENV__Code *SOAP_ENV__Code,
	struct SOAP_ENV__Reason *SOAP_ENV__Reason,
	char *SOAP_ENV__Node,
	char *SOAP_ENV__Role,
	struct SOAP_ENV__Detail *SOAP_ENV__Detail)
{
	struct SOAP_ENV__Fault *_p = soap_new_SOAP_ENV__Fault(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Fault(soap, _p);
		_p->faultcode = faultcode;
		_p->faultstring = faultstring;
		_p->faultactor = faultactor;
		_p->detail = detail;
		_p->SOAP_ENV__Code = SOAP_ENV__Code;
		_p->SOAP_ENV__Reason = SOAP_ENV__Reason;
		_p->SOAP_ENV__Node = SOAP_ENV__Node;
		_p->SOAP_ENV__Role = SOAP_ENV__Role;
		_p->SOAP_ENV__Detail = SOAP_ENV__Detail;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *, const char*, const char*);

inline int soap_write_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_SOAP_ENV__Fault(soap, p), 0) || soap_put_SOAP_ENV__Fault(soap, p, "SOAP-ENV:Fault", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *, const char*, const char*);

inline int soap_read_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{
	if (p)
	{	soap_default_SOAP_ENV__Fault(soap, p);
		if (soap_begin_recv(soap) || soap_get_SOAP_ENV__Fault(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason_DEFINED
#define SOAP_TYPE_SOAP_ENV__Reason_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap*, const char*, int, const struct SOAP_ENV__Reason *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 Server_Soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Reason * soap_new_SOAP_ENV__Reason(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Reason * soap_new_req_SOAP_ENV__Reason(
	struct soap *soap)
{
	struct SOAP_ENV__Reason *_p = soap_new_SOAP_ENV__Reason(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Reason(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Reason * soap_new_set_SOAP_ENV__Reason(
	struct soap *soap,
	char *SOAP_ENV__Text)
{
	struct SOAP_ENV__Reason *_p = soap_new_SOAP_ENV__Reason(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Reason(soap, _p);
		_p->SOAP_ENV__Text = SOAP_ENV__Text;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *, const char*, const char*);

inline int soap_write_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_SOAP_ENV__Reason(soap, p), 0) || soap_put_SOAP_ENV__Reason(soap, p, "SOAP-ENV:Reason", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *, const char*, const char*);

inline int soap_read_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{
	if (p)
	{	soap_default_SOAP_ENV__Reason(soap, p);
		if (soap_begin_recv(soap) || soap_get_SOAP_ENV__Reason(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail_DEFINED
#define SOAP_TYPE_SOAP_ENV__Detail_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap*, const char*, int, const struct SOAP_ENV__Detail *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 Server_Soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Detail * soap_new_SOAP_ENV__Detail(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Detail * soap_new_req_SOAP_ENV__Detail(
	struct soap *soap,
	int __type,
	void *fault)
{
	struct SOAP_ENV__Detail *_p = soap_new_SOAP_ENV__Detail(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Detail(soap, _p);
		_p->__type = __type;
		_p->fault = fault;
	}
	return _p;
}

inline struct SOAP_ENV__Detail * soap_new_set_SOAP_ENV__Detail(
	struct soap *soap,
	char *__any,
	int __type,
	void *fault)
{
	struct SOAP_ENV__Detail *_p = soap_new_SOAP_ENV__Detail(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Detail(soap, _p);
		_p->__any = __any;
		_p->__type = __type;
		_p->fault = fault;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *, const char*, const char*);

inline int soap_write_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_SOAP_ENV__Detail(soap, p), 0) || soap_put_SOAP_ENV__Detail(soap, p, "SOAP-ENV:Detail", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *, const char*, const char*);

inline int soap_read_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{
	if (p)
	{	soap_default_SOAP_ENV__Detail(soap, p);
		if (soap_begin_recv(soap) || soap_get_SOAP_ENV__Detail(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code_DEFINED
#define SOAP_TYPE_SOAP_ENV__Code_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap*, const char*, int, const struct SOAP_ENV__Code *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 Server_Soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Code * soap_new_SOAP_ENV__Code(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Code * soap_new_req_SOAP_ENV__Code(
	struct soap *soap)
{
	struct SOAP_ENV__Code *_p = soap_new_SOAP_ENV__Code(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Code(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Code * soap_new_set_SOAP_ENV__Code(
	struct soap *soap,
	char *SOAP_ENV__Value,
	struct SOAP_ENV__Code *SOAP_ENV__Subcode)
{
	struct SOAP_ENV__Code *_p = soap_new_SOAP_ENV__Code(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Code(soap, _p);
		_p->SOAP_ENV__Value = SOAP_ENV__Value;
		_p->SOAP_ENV__Subcode = SOAP_ENV__Subcode;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *, const char*, const char*);

inline int soap_write_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_SOAP_ENV__Code(soap, p), 0) || soap_put_SOAP_ENV__Code(soap, p, "SOAP-ENV:Code", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *, const char*, const char*);

inline int soap_read_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{
	if (p)
	{	soap_default_SOAP_ENV__Code(soap, p);
		if (soap_begin_recv(soap) || soap_get_SOAP_ENV__Code(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header_DEFINED
#define SOAP_TYPE_SOAP_ENV__Header_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap*, const char*, int, const struct SOAP_ENV__Header *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap*, const char*, struct SOAP_ENV__Header *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 Server_Soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Header * soap_new_SOAP_ENV__Header(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Header * soap_new_req_SOAP_ENV__Header(
	struct soap *soap)
{
	struct SOAP_ENV__Header *_p = soap_new_SOAP_ENV__Header(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Header(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Header * soap_new_set_SOAP_ENV__Header(
	struct soap *soap)
{
	struct SOAP_ENV__Header *_p = soap_new_SOAP_ENV__Header(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Header(soap, _p);
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *, const char*, const char*);

inline int soap_write_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_SOAP_ENV__Header(soap, p), 0) || soap_put_SOAP_ENV__Header(soap, p, "SOAP-ENV:Header", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *, const char*, const char*);

inline int soap_read_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{
	if (p)
	{	soap_default_SOAP_ENV__Header(soap, p);
		if (soap_begin_recv(soap) || soap_get_SOAP_ENV__Header(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#endif

#ifndef SOAP_TYPE_ns__ChangeDeviceName_DEFINED
#define SOAP_TYPE_ns__ChangeDeviceName_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ChangeDeviceName(struct soap*, struct ns__ChangeDeviceName *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ChangeDeviceName(struct soap*, const struct ns__ChangeDeviceName *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ChangeDeviceName(struct soap*, const char*, int, const struct ns__ChangeDeviceName *, const char*);
SOAP_FMAC3 struct ns__ChangeDeviceName * SOAP_FMAC4 soap_in_ns__ChangeDeviceName(struct soap*, const char*, struct ns__ChangeDeviceName *, const char*);
SOAP_FMAC1 struct ns__ChangeDeviceName * SOAP_FMAC2 Server_Soap_instantiate_ns__ChangeDeviceName(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__ChangeDeviceName * soap_new_ns__ChangeDeviceName(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__ChangeDeviceName(soap, n, NULL, NULL, NULL);
}

inline struct ns__ChangeDeviceName * soap_new_req_ns__ChangeDeviceName(
	struct soap *soap,
	const ns__User& requestUserInfo,
	int deviceSerialNumber,
	const std::string& newCityName,
	const std::string& newLocationName,
	const std::string& newDeviceName)
{
	struct ns__ChangeDeviceName *_p = soap_new_ns__ChangeDeviceName(soap);
	if (_p)
	{	soap_default_ns__ChangeDeviceName(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->deviceSerialNumber = deviceSerialNumber;
		_p->newCityName = newCityName;
		_p->newLocationName = newLocationName;
		_p->newDeviceName = newDeviceName;
	}
	return _p;
}

inline struct ns__ChangeDeviceName * soap_new_set_ns__ChangeDeviceName(
	struct soap *soap,
	const ns__User& requestUserInfo,
	int deviceSerialNumber,
	const std::string& newCityName,
	const std::string& newLocationName,
	const std::string& newDeviceName)
{
	struct ns__ChangeDeviceName *_p = soap_new_ns__ChangeDeviceName(soap);
	if (_p)
	{	soap_default_ns__ChangeDeviceName(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->deviceSerialNumber = deviceSerialNumber;
		_p->newCityName = newCityName;
		_p->newLocationName = newLocationName;
		_p->newDeviceName = newDeviceName;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ChangeDeviceName(struct soap*, const struct ns__ChangeDeviceName *, const char*, const char*);

inline int soap_write_ns__ChangeDeviceName(struct soap *soap, struct ns__ChangeDeviceName const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__ChangeDeviceName(soap, p), 0) || soap_put_ns__ChangeDeviceName(soap, p, "ns:ChangeDeviceName", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__ChangeDeviceName * SOAP_FMAC4 soap_get_ns__ChangeDeviceName(struct soap*, struct ns__ChangeDeviceName *, const char*, const char*);

inline int soap_read_ns__ChangeDeviceName(struct soap *soap, struct ns__ChangeDeviceName *p)
{
	if (p)
	{	soap_default_ns__ChangeDeviceName(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__ChangeDeviceName(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__ChangeLocationName_DEFINED
#define SOAP_TYPE_ns__ChangeLocationName_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ChangeLocationName(struct soap*, struct ns__ChangeLocationName *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ChangeLocationName(struct soap*, const struct ns__ChangeLocationName *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ChangeLocationName(struct soap*, const char*, int, const struct ns__ChangeLocationName *, const char*);
SOAP_FMAC3 struct ns__ChangeLocationName * SOAP_FMAC4 soap_in_ns__ChangeLocationName(struct soap*, const char*, struct ns__ChangeLocationName *, const char*);
SOAP_FMAC1 struct ns__ChangeLocationName * SOAP_FMAC2 Server_Soap_instantiate_ns__ChangeLocationName(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__ChangeLocationName * soap_new_ns__ChangeLocationName(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__ChangeLocationName(soap, n, NULL, NULL, NULL);
}

inline struct ns__ChangeLocationName * soap_new_req_ns__ChangeLocationName(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const std::string& oldCityName,
	const std::string& newCityName,
	const std::string& oldLocationName,
	const std::string& newLocationName)
{
	struct ns__ChangeLocationName *_p = soap_new_ns__ChangeLocationName(soap);
	if (_p)
	{	soap_default_ns__ChangeLocationName(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->oldCityName = oldCityName;
		_p->newCityName = newCityName;
		_p->oldLocationName = oldLocationName;
		_p->newLocationName = newLocationName;
	}
	return _p;
}

inline struct ns__ChangeLocationName * soap_new_set_ns__ChangeLocationName(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const std::string& oldCityName,
	const std::string& newCityName,
	const std::string& oldLocationName,
	const std::string& newLocationName)
{
	struct ns__ChangeLocationName *_p = soap_new_ns__ChangeLocationName(soap);
	if (_p)
	{	soap_default_ns__ChangeLocationName(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->oldCityName = oldCityName;
		_p->newCityName = newCityName;
		_p->oldLocationName = oldLocationName;
		_p->newLocationName = newLocationName;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ChangeLocationName(struct soap*, const struct ns__ChangeLocationName *, const char*, const char*);

inline int soap_write_ns__ChangeLocationName(struct soap *soap, struct ns__ChangeLocationName const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__ChangeLocationName(soap, p), 0) || soap_put_ns__ChangeLocationName(soap, p, "ns:ChangeLocationName", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__ChangeLocationName * SOAP_FMAC4 soap_get_ns__ChangeLocationName(struct soap*, struct ns__ChangeLocationName *, const char*, const char*);

inline int soap_read_ns__ChangeLocationName(struct soap *soap, struct ns__ChangeLocationName *p)
{
	if (p)
	{	soap_default_ns__ChangeLocationName(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__ChangeLocationName(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__ChangeCityName_DEFINED
#define SOAP_TYPE_ns__ChangeCityName_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ChangeCityName(struct soap*, struct ns__ChangeCityName *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ChangeCityName(struct soap*, const struct ns__ChangeCityName *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ChangeCityName(struct soap*, const char*, int, const struct ns__ChangeCityName *, const char*);
SOAP_FMAC3 struct ns__ChangeCityName * SOAP_FMAC4 soap_in_ns__ChangeCityName(struct soap*, const char*, struct ns__ChangeCityName *, const char*);
SOAP_FMAC1 struct ns__ChangeCityName * SOAP_FMAC2 Server_Soap_instantiate_ns__ChangeCityName(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__ChangeCityName * soap_new_ns__ChangeCityName(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__ChangeCityName(soap, n, NULL, NULL, NULL);
}

inline struct ns__ChangeCityName * soap_new_req_ns__ChangeCityName(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const std::string& oldCityName,
	const std::string& newCityName)
{
	struct ns__ChangeCityName *_p = soap_new_ns__ChangeCityName(soap);
	if (_p)
	{	soap_default_ns__ChangeCityName(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->oldCityName = oldCityName;
		_p->newCityName = newCityName;
	}
	return _p;
}

inline struct ns__ChangeCityName * soap_new_set_ns__ChangeCityName(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const std::string& oldCityName,
	const std::string& newCityName)
{
	struct ns__ChangeCityName *_p = soap_new_ns__ChangeCityName(soap);
	if (_p)
	{	soap_default_ns__ChangeCityName(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->oldCityName = oldCityName;
		_p->newCityName = newCityName;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ChangeCityName(struct soap*, const struct ns__ChangeCityName *, const char*, const char*);

inline int soap_write_ns__ChangeCityName(struct soap *soap, struct ns__ChangeCityName const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__ChangeCityName(soap, p), 0) || soap_put_ns__ChangeCityName(soap, p, "ns:ChangeCityName", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__ChangeCityName * SOAP_FMAC4 soap_get_ns__ChangeCityName(struct soap*, struct ns__ChangeCityName *, const char*, const char*);

inline int soap_read_ns__ChangeCityName(struct soap *soap, struct ns__ChangeCityName *p)
{
	if (p)
	{	soap_default_ns__ChangeCityName(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__ChangeCityName(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__GetCityAndLocations_DEFINED
#define SOAP_TYPE_ns__GetCityAndLocations_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetCityAndLocations(struct soap*, struct ns__GetCityAndLocations *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetCityAndLocations(struct soap*, const struct ns__GetCityAndLocations *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetCityAndLocations(struct soap*, const char*, int, const struct ns__GetCityAndLocations *, const char*);
SOAP_FMAC3 struct ns__GetCityAndLocations * SOAP_FMAC4 soap_in_ns__GetCityAndLocations(struct soap*, const char*, struct ns__GetCityAndLocations *, const char*);
SOAP_FMAC1 struct ns__GetCityAndLocations * SOAP_FMAC2 Server_Soap_instantiate_ns__GetCityAndLocations(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__GetCityAndLocations * soap_new_ns__GetCityAndLocations(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__GetCityAndLocations(soap, n, NULL, NULL, NULL);
}

inline struct ns__GetCityAndLocations * soap_new_req_ns__GetCityAndLocations(
	struct soap *soap,
	const ns__User& requestUserInfo)
{
	struct ns__GetCityAndLocations *_p = soap_new_ns__GetCityAndLocations(soap);
	if (_p)
	{	soap_default_ns__GetCityAndLocations(soap, _p);
		_p->requestUserInfo = requestUserInfo;
	}
	return _p;
}

inline struct ns__GetCityAndLocations * soap_new_set_ns__GetCityAndLocations(
	struct soap *soap,
	const ns__User& requestUserInfo)
{
	struct ns__GetCityAndLocations *_p = soap_new_ns__GetCityAndLocations(soap);
	if (_p)
	{	soap_default_ns__GetCityAndLocations(soap, _p);
		_p->requestUserInfo = requestUserInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetCityAndLocations(struct soap*, const struct ns__GetCityAndLocations *, const char*, const char*);

inline int soap_write_ns__GetCityAndLocations(struct soap *soap, struct ns__GetCityAndLocations const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__GetCityAndLocations(soap, p), 0) || soap_put_ns__GetCityAndLocations(soap, p, "ns:GetCityAndLocations", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__GetCityAndLocations * SOAP_FMAC4 soap_get_ns__GetCityAndLocations(struct soap*, struct ns__GetCityAndLocations *, const char*, const char*);

inline int soap_read_ns__GetCityAndLocations(struct soap *soap, struct ns__GetCityAndLocations *p)
{
	if (p)
	{	soap_default_ns__GetCityAndLocations(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__GetCityAndLocations(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__SetServerOptions_DEFINED
#define SOAP_TYPE_ns__SetServerOptions_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetServerOptions(struct soap*, struct ns__SetServerOptions *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetServerOptions(struct soap*, const struct ns__SetServerOptions *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetServerOptions(struct soap*, const char*, int, const struct ns__SetServerOptions *, const char*);
SOAP_FMAC3 struct ns__SetServerOptions * SOAP_FMAC4 soap_in_ns__SetServerOptions(struct soap*, const char*, struct ns__SetServerOptions *, const char*);
SOAP_FMAC1 struct ns__SetServerOptions * SOAP_FMAC2 Server_Soap_instantiate_ns__SetServerOptions(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__SetServerOptions * soap_new_ns__SetServerOptions(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__SetServerOptions(soap, n, NULL, NULL, NULL);
}

inline struct ns__SetServerOptions * soap_new_req_ns__SetServerOptions(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__ServerOptions& serverOptions)
{
	struct ns__SetServerOptions *_p = soap_new_ns__SetServerOptions(soap);
	if (_p)
	{	soap_default_ns__SetServerOptions(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->serverOptions = serverOptions;
	}
	return _p;
}

inline struct ns__SetServerOptions * soap_new_set_ns__SetServerOptions(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__ServerOptions& serverOptions)
{
	struct ns__SetServerOptions *_p = soap_new_ns__SetServerOptions(soap);
	if (_p)
	{	soap_default_ns__SetServerOptions(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->serverOptions = serverOptions;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetServerOptions(struct soap*, const struct ns__SetServerOptions *, const char*, const char*);

inline int soap_write_ns__SetServerOptions(struct soap *soap, struct ns__SetServerOptions const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__SetServerOptions(soap, p), 0) || soap_put_ns__SetServerOptions(soap, p, "ns:SetServerOptions", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__SetServerOptions * SOAP_FMAC4 soap_get_ns__SetServerOptions(struct soap*, struct ns__SetServerOptions *, const char*, const char*);

inline int soap_read_ns__SetServerOptions(struct soap *soap, struct ns__SetServerOptions *p)
{
	if (p)
	{	soap_default_ns__SetServerOptions(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__SetServerOptions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__GetServerOptions_DEFINED
#define SOAP_TYPE_ns__GetServerOptions_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetServerOptions(struct soap*, struct ns__GetServerOptions *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetServerOptions(struct soap*, const struct ns__GetServerOptions *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetServerOptions(struct soap*, const char*, int, const struct ns__GetServerOptions *, const char*);
SOAP_FMAC3 struct ns__GetServerOptions * SOAP_FMAC4 soap_in_ns__GetServerOptions(struct soap*, const char*, struct ns__GetServerOptions *, const char*);
SOAP_FMAC1 struct ns__GetServerOptions * SOAP_FMAC2 Server_Soap_instantiate_ns__GetServerOptions(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__GetServerOptions * soap_new_ns__GetServerOptions(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__GetServerOptions(soap, n, NULL, NULL, NULL);
}

inline struct ns__GetServerOptions * soap_new_req_ns__GetServerOptions(
	struct soap *soap,
	const ns__User& requestUserInfo)
{
	struct ns__GetServerOptions *_p = soap_new_ns__GetServerOptions(soap);
	if (_p)
	{	soap_default_ns__GetServerOptions(soap, _p);
		_p->requestUserInfo = requestUserInfo;
	}
	return _p;
}

inline struct ns__GetServerOptions * soap_new_set_ns__GetServerOptions(
	struct soap *soap,
	const ns__User& requestUserInfo)
{
	struct ns__GetServerOptions *_p = soap_new_ns__GetServerOptions(soap);
	if (_p)
	{	soap_default_ns__GetServerOptions(soap, _p);
		_p->requestUserInfo = requestUserInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetServerOptions(struct soap*, const struct ns__GetServerOptions *, const char*, const char*);

inline int soap_write_ns__GetServerOptions(struct soap *soap, struct ns__GetServerOptions const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__GetServerOptions(soap, p), 0) || soap_put_ns__GetServerOptions(soap, p, "ns:GetServerOptions", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__GetServerOptions * SOAP_FMAC4 soap_get_ns__GetServerOptions(struct soap*, struct ns__GetServerOptions *, const char*, const char*);

inline int soap_read_ns__GetServerOptions(struct soap *soap, struct ns__GetServerOptions *p)
{
	if (p)
	{	soap_default_ns__GetServerOptions(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__GetServerOptions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__GetDeviceStatusLog_DEFINED
#define SOAP_TYPE_ns__GetDeviceStatusLog_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetDeviceStatusLog(struct soap*, struct ns__GetDeviceStatusLog *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetDeviceStatusLog(struct soap*, const struct ns__GetDeviceStatusLog *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetDeviceStatusLog(struct soap*, const char*, int, const struct ns__GetDeviceStatusLog *, const char*);
SOAP_FMAC3 struct ns__GetDeviceStatusLog * SOAP_FMAC4 soap_in_ns__GetDeviceStatusLog(struct soap*, const char*, struct ns__GetDeviceStatusLog *, const char*);
SOAP_FMAC1 struct ns__GetDeviceStatusLog * SOAP_FMAC2 Server_Soap_instantiate_ns__GetDeviceStatusLog(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__GetDeviceStatusLog * soap_new_ns__GetDeviceStatusLog(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__GetDeviceStatusLog(soap, n, NULL, NULL, NULL);
}

inline struct ns__GetDeviceStatusLog * soap_new_req_ns__GetDeviceStatusLog(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__DeviceStatusInfo& requestStatusLogInfo)
{
	struct ns__GetDeviceStatusLog *_p = soap_new_ns__GetDeviceStatusLog(soap);
	if (_p)
	{	soap_default_ns__GetDeviceStatusLog(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestStatusLogInfo = requestStatusLogInfo;
	}
	return _p;
}

inline struct ns__GetDeviceStatusLog * soap_new_set_ns__GetDeviceStatusLog(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__DeviceStatusInfo& requestStatusLogInfo)
{
	struct ns__GetDeviceStatusLog *_p = soap_new_ns__GetDeviceStatusLog(soap);
	if (_p)
	{	soap_default_ns__GetDeviceStatusLog(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestStatusLogInfo = requestStatusLogInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetDeviceStatusLog(struct soap*, const struct ns__GetDeviceStatusLog *, const char*, const char*);

inline int soap_write_ns__GetDeviceStatusLog(struct soap *soap, struct ns__GetDeviceStatusLog const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__GetDeviceStatusLog(soap, p), 0) || soap_put_ns__GetDeviceStatusLog(soap, p, "ns:GetDeviceStatusLog", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__GetDeviceStatusLog * SOAP_FMAC4 soap_get_ns__GetDeviceStatusLog(struct soap*, struct ns__GetDeviceStatusLog *, const char*, const char*);

inline int soap_read_ns__GetDeviceStatusLog(struct soap *soap, struct ns__GetDeviceStatusLog *p)
{
	if (p)
	{	soap_default_ns__GetDeviceStatusLog(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__GetDeviceStatusLog(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__SaveDeviceStatusLog_DEFINED
#define SOAP_TYPE_ns__SaveDeviceStatusLog_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SaveDeviceStatusLog(struct soap*, struct ns__SaveDeviceStatusLog *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SaveDeviceStatusLog(struct soap*, const struct ns__SaveDeviceStatusLog *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SaveDeviceStatusLog(struct soap*, const char*, int, const struct ns__SaveDeviceStatusLog *, const char*);
SOAP_FMAC3 struct ns__SaveDeviceStatusLog * SOAP_FMAC4 soap_in_ns__SaveDeviceStatusLog(struct soap*, const char*, struct ns__SaveDeviceStatusLog *, const char*);
SOAP_FMAC1 struct ns__SaveDeviceStatusLog * SOAP_FMAC2 Server_Soap_instantiate_ns__SaveDeviceStatusLog(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__SaveDeviceStatusLog * soap_new_ns__SaveDeviceStatusLog(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__SaveDeviceStatusLog(soap, n, NULL, NULL, NULL);
}

inline struct ns__SaveDeviceStatusLog * soap_new_req_ns__SaveDeviceStatusLog(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__DeviceStatusLog& requestStatusLogInfo)
{
	struct ns__SaveDeviceStatusLog *_p = soap_new_ns__SaveDeviceStatusLog(soap);
	if (_p)
	{	soap_default_ns__SaveDeviceStatusLog(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestStatusLogInfo = requestStatusLogInfo;
	}
	return _p;
}

inline struct ns__SaveDeviceStatusLog * soap_new_set_ns__SaveDeviceStatusLog(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__DeviceStatusLog& requestStatusLogInfo)
{
	struct ns__SaveDeviceStatusLog *_p = soap_new_ns__SaveDeviceStatusLog(soap);
	if (_p)
	{	soap_default_ns__SaveDeviceStatusLog(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestStatusLogInfo = requestStatusLogInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SaveDeviceStatusLog(struct soap*, const struct ns__SaveDeviceStatusLog *, const char*, const char*);

inline int soap_write_ns__SaveDeviceStatusLog(struct soap *soap, struct ns__SaveDeviceStatusLog const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__SaveDeviceStatusLog(soap, p), 0) || soap_put_ns__SaveDeviceStatusLog(soap, p, "ns:SaveDeviceStatusLog", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__SaveDeviceStatusLog * SOAP_FMAC4 soap_get_ns__SaveDeviceStatusLog(struct soap*, struct ns__SaveDeviceStatusLog *, const char*, const char*);

inline int soap_read_ns__SaveDeviceStatusLog(struct soap *soap, struct ns__SaveDeviceStatusLog *p)
{
	if (p)
	{	soap_default_ns__SaveDeviceStatusLog(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__SaveDeviceStatusLog(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__GetUserLog_DEFINED
#define SOAP_TYPE_ns__GetUserLog_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetUserLog(struct soap*, struct ns__GetUserLog *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetUserLog(struct soap*, const struct ns__GetUserLog *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetUserLog(struct soap*, const char*, int, const struct ns__GetUserLog *, const char*);
SOAP_FMAC3 struct ns__GetUserLog * SOAP_FMAC4 soap_in_ns__GetUserLog(struct soap*, const char*, struct ns__GetUserLog *, const char*);
SOAP_FMAC1 struct ns__GetUserLog * SOAP_FMAC2 Server_Soap_instantiate_ns__GetUserLog(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__GetUserLog * soap_new_ns__GetUserLog(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__GetUserLog(soap, n, NULL, NULL, NULL);
}

inline struct ns__GetUserLog * soap_new_req_ns__GetUserLog(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__ReportRange& requestReportInfo)
{
	struct ns__GetUserLog *_p = soap_new_ns__GetUserLog(soap);
	if (_p)
	{	soap_default_ns__GetUserLog(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestReportInfo = requestReportInfo;
	}
	return _p;
}

inline struct ns__GetUserLog * soap_new_set_ns__GetUserLog(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__ReportRange& requestReportInfo)
{
	struct ns__GetUserLog *_p = soap_new_ns__GetUserLog(soap);
	if (_p)
	{	soap_default_ns__GetUserLog(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestReportInfo = requestReportInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetUserLog(struct soap*, const struct ns__GetUserLog *, const char*, const char*);

inline int soap_write_ns__GetUserLog(struct soap *soap, struct ns__GetUserLog const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__GetUserLog(soap, p), 0) || soap_put_ns__GetUserLog(soap, p, "ns:GetUserLog", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__GetUserLog * SOAP_FMAC4 soap_get_ns__GetUserLog(struct soap*, struct ns__GetUserLog *, const char*, const char*);

inline int soap_read_ns__GetUserLog(struct soap *soap, struct ns__GetUserLog *p)
{
	if (p)
	{	soap_default_ns__GetUserLog(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__GetUserLog(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__GetUserLogResponse_DEFINED
#define SOAP_TYPE_ns__GetUserLogResponse_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetUserLogResponse(struct soap*, struct ns__GetUserLogResponse *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetUserLogResponse(struct soap*, const struct ns__GetUserLogResponse *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetUserLogResponse(struct soap*, const char*, int, const struct ns__GetUserLogResponse *, const char*);
SOAP_FMAC3 struct ns__GetUserLogResponse * SOAP_FMAC4 soap_in_ns__GetUserLogResponse(struct soap*, const char*, struct ns__GetUserLogResponse *, const char*);
SOAP_FMAC1 struct ns__GetUserLogResponse * SOAP_FMAC2 Server_Soap_instantiate_ns__GetUserLogResponse(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__GetUserLogResponse * soap_new_ns__GetUserLogResponse(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__GetUserLogResponse(soap, n, NULL, NULL, NULL);
}

inline struct ns__GetUserLogResponse * soap_new_req_ns__GetUserLogResponse(
	struct soap *soap,
	const std::vector<ns__UserLog> & responseActivityLogInfo)
{
	struct ns__GetUserLogResponse *_p = soap_new_ns__GetUserLogResponse(soap);
	if (_p)
	{	soap_default_ns__GetUserLogResponse(soap, _p);
		_p->responseActivityLogInfo = responseActivityLogInfo;
	}
	return _p;
}

inline struct ns__GetUserLogResponse * soap_new_set_ns__GetUserLogResponse(
	struct soap *soap,
	const std::vector<ns__UserLog> & responseActivityLogInfo)
{
	struct ns__GetUserLogResponse *_p = soap_new_ns__GetUserLogResponse(soap);
	if (_p)
	{	soap_default_ns__GetUserLogResponse(soap, _p);
		_p->responseActivityLogInfo = responseActivityLogInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetUserLogResponse(struct soap*, const struct ns__GetUserLogResponse *, const char*, const char*);

inline int soap_write_ns__GetUserLogResponse(struct soap *soap, struct ns__GetUserLogResponse const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__GetUserLogResponse(soap, p), 0) || soap_put_ns__GetUserLogResponse(soap, p, "ns:GetUserLogResponse", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__GetUserLogResponse * SOAP_FMAC4 soap_get_ns__GetUserLogResponse(struct soap*, struct ns__GetUserLogResponse *, const char*, const char*);

inline int soap_read_ns__GetUserLogResponse(struct soap *soap, struct ns__GetUserLogResponse *p)
{
	if (p)
	{	soap_default_ns__GetUserLogResponse(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__GetUserLogResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__SaveUserLog_DEFINED
#define SOAP_TYPE_ns__SaveUserLog_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SaveUserLog(struct soap*, struct ns__SaveUserLog *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SaveUserLog(struct soap*, const struct ns__SaveUserLog *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SaveUserLog(struct soap*, const char*, int, const struct ns__SaveUserLog *, const char*);
SOAP_FMAC3 struct ns__SaveUserLog * SOAP_FMAC4 soap_in_ns__SaveUserLog(struct soap*, const char*, struct ns__SaveUserLog *, const char*);
SOAP_FMAC1 struct ns__SaveUserLog * SOAP_FMAC2 Server_Soap_instantiate_ns__SaveUserLog(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__SaveUserLog * soap_new_ns__SaveUserLog(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__SaveUserLog(soap, n, NULL, NULL, NULL);
}

inline struct ns__SaveUserLog * soap_new_req_ns__SaveUserLog(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__UserLog& requestActivityLogInfo)
{
	struct ns__SaveUserLog *_p = soap_new_ns__SaveUserLog(soap);
	if (_p)
	{	soap_default_ns__SaveUserLog(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestActivityLogInfo = requestActivityLogInfo;
	}
	return _p;
}

inline struct ns__SaveUserLog * soap_new_set_ns__SaveUserLog(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__UserLog& requestActivityLogInfo)
{
	struct ns__SaveUserLog *_p = soap_new_ns__SaveUserLog(soap);
	if (_p)
	{	soap_default_ns__SaveUserLog(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestActivityLogInfo = requestActivityLogInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SaveUserLog(struct soap*, const struct ns__SaveUserLog *, const char*, const char*);

inline int soap_write_ns__SaveUserLog(struct soap *soap, struct ns__SaveUserLog const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__SaveUserLog(soap, p), 0) || soap_put_ns__SaveUserLog(soap, p, "ns:SaveUserLog", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__SaveUserLog * SOAP_FMAC4 soap_get_ns__SaveUserLog(struct soap*, struct ns__SaveUserLog *, const char*, const char*);

inline int soap_read_ns__SaveUserLog(struct soap *soap, struct ns__SaveUserLog *p)
{
	if (p)
	{	soap_default_ns__SaveUserLog(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__SaveUserLog(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__GetActivityLog_DEFINED
#define SOAP_TYPE_ns__GetActivityLog_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetActivityLog(struct soap*, struct ns__GetActivityLog *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetActivityLog(struct soap*, const struct ns__GetActivityLog *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetActivityLog(struct soap*, const char*, int, const struct ns__GetActivityLog *, const char*);
SOAP_FMAC3 struct ns__GetActivityLog * SOAP_FMAC4 soap_in_ns__GetActivityLog(struct soap*, const char*, struct ns__GetActivityLog *, const char*);
SOAP_FMAC1 struct ns__GetActivityLog * SOAP_FMAC2 Server_Soap_instantiate_ns__GetActivityLog(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__GetActivityLog * soap_new_ns__GetActivityLog(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__GetActivityLog(soap, n, NULL, NULL, NULL);
}

inline struct ns__GetActivityLog * soap_new_req_ns__GetActivityLog(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__ReportRange& requestReportInfo)
{
	struct ns__GetActivityLog *_p = soap_new_ns__GetActivityLog(soap);
	if (_p)
	{	soap_default_ns__GetActivityLog(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestReportInfo = requestReportInfo;
	}
	return _p;
}

inline struct ns__GetActivityLog * soap_new_set_ns__GetActivityLog(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__ReportRange& requestReportInfo)
{
	struct ns__GetActivityLog *_p = soap_new_ns__GetActivityLog(soap);
	if (_p)
	{	soap_default_ns__GetActivityLog(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestReportInfo = requestReportInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetActivityLog(struct soap*, const struct ns__GetActivityLog *, const char*, const char*);

inline int soap_write_ns__GetActivityLog(struct soap *soap, struct ns__GetActivityLog const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__GetActivityLog(soap, p), 0) || soap_put_ns__GetActivityLog(soap, p, "ns:GetActivityLog", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__GetActivityLog * SOAP_FMAC4 soap_get_ns__GetActivityLog(struct soap*, struct ns__GetActivityLog *, const char*, const char*);

inline int soap_read_ns__GetActivityLog(struct soap *soap, struct ns__GetActivityLog *p)
{
	if (p)
	{	soap_default_ns__GetActivityLog(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__GetActivityLog(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__GetActivityLogResponse_DEFINED
#define SOAP_TYPE_ns__GetActivityLogResponse_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetActivityLogResponse(struct soap*, struct ns__GetActivityLogResponse *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetActivityLogResponse(struct soap*, const struct ns__GetActivityLogResponse *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetActivityLogResponse(struct soap*, const char*, int, const struct ns__GetActivityLogResponse *, const char*);
SOAP_FMAC3 struct ns__GetActivityLogResponse * SOAP_FMAC4 soap_in_ns__GetActivityLogResponse(struct soap*, const char*, struct ns__GetActivityLogResponse *, const char*);
SOAP_FMAC1 struct ns__GetActivityLogResponse * SOAP_FMAC2 Server_Soap_instantiate_ns__GetActivityLogResponse(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__GetActivityLogResponse * soap_new_ns__GetActivityLogResponse(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__GetActivityLogResponse(soap, n, NULL, NULL, NULL);
}

inline struct ns__GetActivityLogResponse * soap_new_req_ns__GetActivityLogResponse(
	struct soap *soap,
	const std::vector<ns__ActivityLog> & responseActivityLogInfo)
{
	struct ns__GetActivityLogResponse *_p = soap_new_ns__GetActivityLogResponse(soap);
	if (_p)
	{	soap_default_ns__GetActivityLogResponse(soap, _p);
		_p->responseActivityLogInfo = responseActivityLogInfo;
	}
	return _p;
}

inline struct ns__GetActivityLogResponse * soap_new_set_ns__GetActivityLogResponse(
	struct soap *soap,
	const std::vector<ns__ActivityLog> & responseActivityLogInfo)
{
	struct ns__GetActivityLogResponse *_p = soap_new_ns__GetActivityLogResponse(soap);
	if (_p)
	{	soap_default_ns__GetActivityLogResponse(soap, _p);
		_p->responseActivityLogInfo = responseActivityLogInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetActivityLogResponse(struct soap*, const struct ns__GetActivityLogResponse *, const char*, const char*);

inline int soap_write_ns__GetActivityLogResponse(struct soap *soap, struct ns__GetActivityLogResponse const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__GetActivityLogResponse(soap, p), 0) || soap_put_ns__GetActivityLogResponse(soap, p, "ns:GetActivityLogResponse", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__GetActivityLogResponse * SOAP_FMAC4 soap_get_ns__GetActivityLogResponse(struct soap*, struct ns__GetActivityLogResponse *, const char*, const char*);

inline int soap_read_ns__GetActivityLogResponse(struct soap *soap, struct ns__GetActivityLogResponse *p)
{
	if (p)
	{	soap_default_ns__GetActivityLogResponse(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__GetActivityLogResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__SaveActivityLog_DEFINED
#define SOAP_TYPE_ns__SaveActivityLog_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SaveActivityLog(struct soap*, struct ns__SaveActivityLog *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SaveActivityLog(struct soap*, const struct ns__SaveActivityLog *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SaveActivityLog(struct soap*, const char*, int, const struct ns__SaveActivityLog *, const char*);
SOAP_FMAC3 struct ns__SaveActivityLog * SOAP_FMAC4 soap_in_ns__SaveActivityLog(struct soap*, const char*, struct ns__SaveActivityLog *, const char*);
SOAP_FMAC1 struct ns__SaveActivityLog * SOAP_FMAC2 Server_Soap_instantiate_ns__SaveActivityLog(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__SaveActivityLog * soap_new_ns__SaveActivityLog(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__SaveActivityLog(soap, n, NULL, NULL, NULL);
}

inline struct ns__SaveActivityLog * soap_new_req_ns__SaveActivityLog(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__ActivityLog& requestActivityLogInfo)
{
	struct ns__SaveActivityLog *_p = soap_new_ns__SaveActivityLog(soap);
	if (_p)
	{	soap_default_ns__SaveActivityLog(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestActivityLogInfo = requestActivityLogInfo;
	}
	return _p;
}

inline struct ns__SaveActivityLog * soap_new_set_ns__SaveActivityLog(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__ActivityLog& requestActivityLogInfo)
{
	struct ns__SaveActivityLog *_p = soap_new_ns__SaveActivityLog(soap);
	if (_p)
	{	soap_default_ns__SaveActivityLog(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestActivityLogInfo = requestActivityLogInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SaveActivityLog(struct soap*, const struct ns__SaveActivityLog *, const char*, const char*);

inline int soap_write_ns__SaveActivityLog(struct soap *soap, struct ns__SaveActivityLog const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__SaveActivityLog(soap, p), 0) || soap_put_ns__SaveActivityLog(soap, p, "ns:SaveActivityLog", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__SaveActivityLog * SOAP_FMAC4 soap_get_ns__SaveActivityLog(struct soap*, struct ns__SaveActivityLog *, const char*, const char*);

inline int soap_read_ns__SaveActivityLog(struct soap *soap, struct ns__SaveActivityLog *p)
{
	if (p)
	{	soap_default_ns__SaveActivityLog(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__SaveActivityLog(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__GetUserDevices_DEFINED
#define SOAP_TYPE_ns__GetUserDevices_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetUserDevices(struct soap*, struct ns__GetUserDevices *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetUserDevices(struct soap*, const struct ns__GetUserDevices *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetUserDevices(struct soap*, const char*, int, const struct ns__GetUserDevices *, const char*);
SOAP_FMAC3 struct ns__GetUserDevices * SOAP_FMAC4 soap_in_ns__GetUserDevices(struct soap*, const char*, struct ns__GetUserDevices *, const char*);
SOAP_FMAC1 struct ns__GetUserDevices * SOAP_FMAC2 Server_Soap_instantiate_ns__GetUserDevices(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__GetUserDevices * soap_new_ns__GetUserDevices(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__GetUserDevices(soap, n, NULL, NULL, NULL);
}

inline struct ns__GetUserDevices * soap_new_req_ns__GetUserDevices(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__User& requestSelectedUserInfo)
{
	struct ns__GetUserDevices *_p = soap_new_ns__GetUserDevices(soap);
	if (_p)
	{	soap_default_ns__GetUserDevices(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestSelectedUserInfo = requestSelectedUserInfo;
	}
	return _p;
}

inline struct ns__GetUserDevices * soap_new_set_ns__GetUserDevices(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__User& requestSelectedUserInfo)
{
	struct ns__GetUserDevices *_p = soap_new_ns__GetUserDevices(soap);
	if (_p)
	{	soap_default_ns__GetUserDevices(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestSelectedUserInfo = requestSelectedUserInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetUserDevices(struct soap*, const struct ns__GetUserDevices *, const char*, const char*);

inline int soap_write_ns__GetUserDevices(struct soap *soap, struct ns__GetUserDevices const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__GetUserDevices(soap, p), 0) || soap_put_ns__GetUserDevices(soap, p, "ns:GetUserDevices", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__GetUserDevices * SOAP_FMAC4 soap_get_ns__GetUserDevices(struct soap*, struct ns__GetUserDevices *, const char*, const char*);

inline int soap_read_ns__GetUserDevices(struct soap *soap, struct ns__GetUserDevices *p)
{
	if (p)
	{	soap_default_ns__GetUserDevices(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__GetUserDevices(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__DeleteDeviceFromUser_DEFINED
#define SOAP_TYPE_ns__DeleteDeviceFromUser_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DeleteDeviceFromUser(struct soap*, struct ns__DeleteDeviceFromUser *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DeleteDeviceFromUser(struct soap*, const struct ns__DeleteDeviceFromUser *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeleteDeviceFromUser(struct soap*, const char*, int, const struct ns__DeleteDeviceFromUser *, const char*);
SOAP_FMAC3 struct ns__DeleteDeviceFromUser * SOAP_FMAC4 soap_in_ns__DeleteDeviceFromUser(struct soap*, const char*, struct ns__DeleteDeviceFromUser *, const char*);
SOAP_FMAC1 struct ns__DeleteDeviceFromUser * SOAP_FMAC2 Server_Soap_instantiate_ns__DeleteDeviceFromUser(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__DeleteDeviceFromUser * soap_new_ns__DeleteDeviceFromUser(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__DeleteDeviceFromUser(soap, n, NULL, NULL, NULL);
}

inline struct ns__DeleteDeviceFromUser * soap_new_req_ns__DeleteDeviceFromUser(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__UserDevice& requestUserDeviceInfo)
{
	struct ns__DeleteDeviceFromUser *_p = soap_new_ns__DeleteDeviceFromUser(soap);
	if (_p)
	{	soap_default_ns__DeleteDeviceFromUser(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestUserDeviceInfo = requestUserDeviceInfo;
	}
	return _p;
}

inline struct ns__DeleteDeviceFromUser * soap_new_set_ns__DeleteDeviceFromUser(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__UserDevice& requestUserDeviceInfo)
{
	struct ns__DeleteDeviceFromUser *_p = soap_new_ns__DeleteDeviceFromUser(soap);
	if (_p)
	{	soap_default_ns__DeleteDeviceFromUser(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestUserDeviceInfo = requestUserDeviceInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DeleteDeviceFromUser(struct soap*, const struct ns__DeleteDeviceFromUser *, const char*, const char*);

inline int soap_write_ns__DeleteDeviceFromUser(struct soap *soap, struct ns__DeleteDeviceFromUser const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__DeleteDeviceFromUser(soap, p), 0) || soap_put_ns__DeleteDeviceFromUser(soap, p, "ns:DeleteDeviceFromUser", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__DeleteDeviceFromUser * SOAP_FMAC4 soap_get_ns__DeleteDeviceFromUser(struct soap*, struct ns__DeleteDeviceFromUser *, const char*, const char*);

inline int soap_read_ns__DeleteDeviceFromUser(struct soap *soap, struct ns__DeleteDeviceFromUser *p)
{
	if (p)
	{	soap_default_ns__DeleteDeviceFromUser(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__DeleteDeviceFromUser(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__AssignDeviceToUser_DEFINED
#define SOAP_TYPE_ns__AssignDeviceToUser_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AssignDeviceToUser(struct soap*, struct ns__AssignDeviceToUser *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__AssignDeviceToUser(struct soap*, const struct ns__AssignDeviceToUser *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AssignDeviceToUser(struct soap*, const char*, int, const struct ns__AssignDeviceToUser *, const char*);
SOAP_FMAC3 struct ns__AssignDeviceToUser * SOAP_FMAC4 soap_in_ns__AssignDeviceToUser(struct soap*, const char*, struct ns__AssignDeviceToUser *, const char*);
SOAP_FMAC1 struct ns__AssignDeviceToUser * SOAP_FMAC2 Server_Soap_instantiate_ns__AssignDeviceToUser(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__AssignDeviceToUser * soap_new_ns__AssignDeviceToUser(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__AssignDeviceToUser(soap, n, NULL, NULL, NULL);
}

inline struct ns__AssignDeviceToUser * soap_new_req_ns__AssignDeviceToUser(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__UserDevice& requestUserDeviceInfo)
{
	struct ns__AssignDeviceToUser *_p = soap_new_ns__AssignDeviceToUser(soap);
	if (_p)
	{	soap_default_ns__AssignDeviceToUser(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestUserDeviceInfo = requestUserDeviceInfo;
	}
	return _p;
}

inline struct ns__AssignDeviceToUser * soap_new_set_ns__AssignDeviceToUser(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__UserDevice& requestUserDeviceInfo)
{
	struct ns__AssignDeviceToUser *_p = soap_new_ns__AssignDeviceToUser(soap);
	if (_p)
	{	soap_default_ns__AssignDeviceToUser(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestUserDeviceInfo = requestUserDeviceInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AssignDeviceToUser(struct soap*, const struct ns__AssignDeviceToUser *, const char*, const char*);

inline int soap_write_ns__AssignDeviceToUser(struct soap *soap, struct ns__AssignDeviceToUser const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__AssignDeviceToUser(soap, p), 0) || soap_put_ns__AssignDeviceToUser(soap, p, "ns:AssignDeviceToUser", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__AssignDeviceToUser * SOAP_FMAC4 soap_get_ns__AssignDeviceToUser(struct soap*, struct ns__AssignDeviceToUser *, const char*, const char*);

inline int soap_read_ns__AssignDeviceToUser(struct soap *soap, struct ns__AssignDeviceToUser *p)
{
	if (p)
	{	soap_default_ns__AssignDeviceToUser(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__AssignDeviceToUser(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__DeleteUser_DEFINED
#define SOAP_TYPE_ns__DeleteUser_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DeleteUser(struct soap*, struct ns__DeleteUser *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DeleteUser(struct soap*, const struct ns__DeleteUser *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeleteUser(struct soap*, const char*, int, const struct ns__DeleteUser *, const char*);
SOAP_FMAC3 struct ns__DeleteUser * SOAP_FMAC4 soap_in_ns__DeleteUser(struct soap*, const char*, struct ns__DeleteUser *, const char*);
SOAP_FMAC1 struct ns__DeleteUser * SOAP_FMAC2 Server_Soap_instantiate_ns__DeleteUser(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__DeleteUser * soap_new_ns__DeleteUser(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__DeleteUser(soap, n, NULL, NULL, NULL);
}

inline struct ns__DeleteUser * soap_new_req_ns__DeleteUser(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__User& requestDeleteUserInfo)
{
	struct ns__DeleteUser *_p = soap_new_ns__DeleteUser(soap);
	if (_p)
	{	soap_default_ns__DeleteUser(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestDeleteUserInfo = requestDeleteUserInfo;
	}
	return _p;
}

inline struct ns__DeleteUser * soap_new_set_ns__DeleteUser(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__User& requestDeleteUserInfo)
{
	struct ns__DeleteUser *_p = soap_new_ns__DeleteUser(soap);
	if (_p)
	{	soap_default_ns__DeleteUser(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestDeleteUserInfo = requestDeleteUserInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DeleteUser(struct soap*, const struct ns__DeleteUser *, const char*, const char*);

inline int soap_write_ns__DeleteUser(struct soap *soap, struct ns__DeleteUser const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__DeleteUser(soap, p), 0) || soap_put_ns__DeleteUser(soap, p, "ns:DeleteUser", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__DeleteUser * SOAP_FMAC4 soap_get_ns__DeleteUser(struct soap*, struct ns__DeleteUser *, const char*, const char*);

inline int soap_read_ns__DeleteUser(struct soap *soap, struct ns__DeleteUser *p)
{
	if (p)
	{	soap_default_ns__DeleteUser(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__DeleteUser(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__UpdateUser_DEFINED
#define SOAP_TYPE_ns__UpdateUser_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__UpdateUser(struct soap*, struct ns__UpdateUser *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__UpdateUser(struct soap*, const struct ns__UpdateUser *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UpdateUser(struct soap*, const char*, int, const struct ns__UpdateUser *, const char*);
SOAP_FMAC3 struct ns__UpdateUser * SOAP_FMAC4 soap_in_ns__UpdateUser(struct soap*, const char*, struct ns__UpdateUser *, const char*);
SOAP_FMAC1 struct ns__UpdateUser * SOAP_FMAC2 Server_Soap_instantiate_ns__UpdateUser(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__UpdateUser * soap_new_ns__UpdateUser(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__UpdateUser(soap, n, NULL, NULL, NULL);
}

inline struct ns__UpdateUser * soap_new_req_ns__UpdateUser(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__User& requestNewUserInfo)
{
	struct ns__UpdateUser *_p = soap_new_ns__UpdateUser(soap);
	if (_p)
	{	soap_default_ns__UpdateUser(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestNewUserInfo = requestNewUserInfo;
	}
	return _p;
}

inline struct ns__UpdateUser * soap_new_set_ns__UpdateUser(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__User& requestNewUserInfo)
{
	struct ns__UpdateUser *_p = soap_new_ns__UpdateUser(soap);
	if (_p)
	{	soap_default_ns__UpdateUser(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestNewUserInfo = requestNewUserInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__UpdateUser(struct soap*, const struct ns__UpdateUser *, const char*, const char*);

inline int soap_write_ns__UpdateUser(struct soap *soap, struct ns__UpdateUser const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__UpdateUser(soap, p), 0) || soap_put_ns__UpdateUser(soap, p, "ns:UpdateUser", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__UpdateUser * SOAP_FMAC4 soap_get_ns__UpdateUser(struct soap*, struct ns__UpdateUser *, const char*, const char*);

inline int soap_read_ns__UpdateUser(struct soap *soap, struct ns__UpdateUser *p)
{
	if (p)
	{	soap_default_ns__UpdateUser(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__UpdateUser(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__AddUser_DEFINED
#define SOAP_TYPE_ns__AddUser_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AddUser(struct soap*, struct ns__AddUser *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__AddUser(struct soap*, const struct ns__AddUser *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AddUser(struct soap*, const char*, int, const struct ns__AddUser *, const char*);
SOAP_FMAC3 struct ns__AddUser * SOAP_FMAC4 soap_in_ns__AddUser(struct soap*, const char*, struct ns__AddUser *, const char*);
SOAP_FMAC1 struct ns__AddUser * SOAP_FMAC2 Server_Soap_instantiate_ns__AddUser(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__AddUser * soap_new_ns__AddUser(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__AddUser(soap, n, NULL, NULL, NULL);
}

inline struct ns__AddUser * soap_new_req_ns__AddUser(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__User& requestNewUserInfo)
{
	struct ns__AddUser *_p = soap_new_ns__AddUser(soap);
	if (_p)
	{	soap_default_ns__AddUser(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestNewUserInfo = requestNewUserInfo;
	}
	return _p;
}

inline struct ns__AddUser * soap_new_set_ns__AddUser(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__User& requestNewUserInfo)
{
	struct ns__AddUser *_p = soap_new_ns__AddUser(soap);
	if (_p)
	{	soap_default_ns__AddUser(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestNewUserInfo = requestNewUserInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AddUser(struct soap*, const struct ns__AddUser *, const char*, const char*);

inline int soap_write_ns__AddUser(struct soap *soap, struct ns__AddUser const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__AddUser(soap, p), 0) || soap_put_ns__AddUser(soap, p, "ns:AddUser", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__AddUser * SOAP_FMAC4 soap_get_ns__AddUser(struct soap*, struct ns__AddUser *, const char*, const char*);

inline int soap_read_ns__AddUser(struct soap *soap, struct ns__AddUser *p)
{
	if (p)
	{	soap_default_ns__AddUser(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__AddUser(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__GetUsersList_DEFINED
#define SOAP_TYPE_ns__GetUsersList_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetUsersList(struct soap*, struct ns__GetUsersList *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetUsersList(struct soap*, const struct ns__GetUsersList *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetUsersList(struct soap*, const char*, int, const struct ns__GetUsersList *, const char*);
SOAP_FMAC3 struct ns__GetUsersList * SOAP_FMAC4 soap_in_ns__GetUsersList(struct soap*, const char*, struct ns__GetUsersList *, const char*);
SOAP_FMAC1 struct ns__GetUsersList * SOAP_FMAC2 Server_Soap_instantiate_ns__GetUsersList(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__GetUsersList * soap_new_ns__GetUsersList(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__GetUsersList(soap, n, NULL, NULL, NULL);
}

inline struct ns__GetUsersList * soap_new_req_ns__GetUsersList(
	struct soap *soap,
	const ns__User& requestUserInfo)
{
	struct ns__GetUsersList *_p = soap_new_ns__GetUsersList(soap);
	if (_p)
	{	soap_default_ns__GetUsersList(soap, _p);
		_p->requestUserInfo = requestUserInfo;
	}
	return _p;
}

inline struct ns__GetUsersList * soap_new_set_ns__GetUsersList(
	struct soap *soap,
	const ns__User& requestUserInfo)
{
	struct ns__GetUsersList *_p = soap_new_ns__GetUsersList(soap);
	if (_p)
	{	soap_default_ns__GetUsersList(soap, _p);
		_p->requestUserInfo = requestUserInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetUsersList(struct soap*, const struct ns__GetUsersList *, const char*, const char*);

inline int soap_write_ns__GetUsersList(struct soap *soap, struct ns__GetUsersList const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__GetUsersList(soap, p), 0) || soap_put_ns__GetUsersList(soap, p, "ns:GetUsersList", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__GetUsersList * SOAP_FMAC4 soap_get_ns__GetUsersList(struct soap*, struct ns__GetUsersList *, const char*, const char*);

inline int soap_read_ns__GetUsersList(struct soap *soap, struct ns__GetUsersList *p)
{
	if (p)
	{	soap_default_ns__GetUsersList(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__GetUsersList(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__GetUserDeviceList_DEFINED
#define SOAP_TYPE_ns__GetUserDeviceList_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetUserDeviceList(struct soap*, struct ns__GetUserDeviceList *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetUserDeviceList(struct soap*, const struct ns__GetUserDeviceList *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetUserDeviceList(struct soap*, const char*, int, const struct ns__GetUserDeviceList *, const char*);
SOAP_FMAC3 struct ns__GetUserDeviceList * SOAP_FMAC4 soap_in_ns__GetUserDeviceList(struct soap*, const char*, struct ns__GetUserDeviceList *, const char*);
SOAP_FMAC1 struct ns__GetUserDeviceList * SOAP_FMAC2 Server_Soap_instantiate_ns__GetUserDeviceList(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__GetUserDeviceList * soap_new_ns__GetUserDeviceList(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__GetUserDeviceList(soap, n, NULL, NULL, NULL);
}

inline struct ns__GetUserDeviceList * soap_new_req_ns__GetUserDeviceList(
	struct soap *soap,
	const ns__User& requestUserInfo)
{
	struct ns__GetUserDeviceList *_p = soap_new_ns__GetUserDeviceList(soap);
	if (_p)
	{	soap_default_ns__GetUserDeviceList(soap, _p);
		_p->requestUserInfo = requestUserInfo;
	}
	return _p;
}

inline struct ns__GetUserDeviceList * soap_new_set_ns__GetUserDeviceList(
	struct soap *soap,
	const ns__User& requestUserInfo)
{
	struct ns__GetUserDeviceList *_p = soap_new_ns__GetUserDeviceList(soap);
	if (_p)
	{	soap_default_ns__GetUserDeviceList(soap, _p);
		_p->requestUserInfo = requestUserInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetUserDeviceList(struct soap*, const struct ns__GetUserDeviceList *, const char*, const char*);

inline int soap_write_ns__GetUserDeviceList(struct soap *soap, struct ns__GetUserDeviceList const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__GetUserDeviceList(soap, p), 0) || soap_put_ns__GetUserDeviceList(soap, p, "ns:GetUserDeviceList", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__GetUserDeviceList * SOAP_FMAC4 soap_get_ns__GetUserDeviceList(struct soap*, struct ns__GetUserDeviceList *, const char*, const char*);

inline int soap_read_ns__GetUserDeviceList(struct soap *soap, struct ns__GetUserDeviceList *p)
{
	if (p)
	{	soap_default_ns__GetUserDeviceList(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__GetUserDeviceList(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__Login_DEFINED
#define SOAP_TYPE_ns__Login_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Login(struct soap*, struct ns__Login *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Login(struct soap*, const struct ns__Login *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Login(struct soap*, const char*, int, const struct ns__Login *, const char*);
SOAP_FMAC3 struct ns__Login * SOAP_FMAC4 soap_in_ns__Login(struct soap*, const char*, struct ns__Login *, const char*);
SOAP_FMAC1 struct ns__Login * SOAP_FMAC2 Server_Soap_instantiate_ns__Login(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__Login * soap_new_ns__Login(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__Login(soap, n, NULL, NULL, NULL);
}

inline struct ns__Login * soap_new_req_ns__Login(
	struct soap *soap,
	const ns__User& requestUserInfo)
{
	struct ns__Login *_p = soap_new_ns__Login(soap);
	if (_p)
	{	soap_default_ns__Login(soap, _p);
		_p->requestUserInfo = requestUserInfo;
	}
	return _p;
}

inline struct ns__Login * soap_new_set_ns__Login(
	struct soap *soap,
	const ns__User& requestUserInfo)
{
	struct ns__Login *_p = soap_new_ns__Login(soap);
	if (_p)
	{	soap_default_ns__Login(soap, _p);
		_p->requestUserInfo = requestUserInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Login(struct soap*, const struct ns__Login *, const char*, const char*);

inline int soap_write_ns__Login(struct soap *soap, struct ns__Login const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__Login(soap, p), 0) || soap_put_ns__Login(soap, p, "ns:Login", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__Login * SOAP_FMAC4 soap_get_ns__Login(struct soap*, struct ns__Login *, const char*, const char*);

inline int soap_read_ns__Login(struct soap *soap, struct ns__Login *p)
{
	if (p)
	{	soap_default_ns__Login(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__Login(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__DeleteDevices_DEFINED
#define SOAP_TYPE_ns__DeleteDevices_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DeleteDevices(struct soap*, struct ns__DeleteDevices *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DeleteDevices(struct soap*, const struct ns__DeleteDevices *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeleteDevices(struct soap*, const char*, int, const struct ns__DeleteDevices *, const char*);
SOAP_FMAC3 struct ns__DeleteDevices * SOAP_FMAC4 soap_in_ns__DeleteDevices(struct soap*, const char*, struct ns__DeleteDevices *, const char*);
SOAP_FMAC1 struct ns__DeleteDevices * SOAP_FMAC2 Server_Soap_instantiate_ns__DeleteDevices(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__DeleteDevices * soap_new_ns__DeleteDevices(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__DeleteDevices(soap, n, NULL, NULL, NULL);
}

inline struct ns__DeleteDevices * soap_new_req_ns__DeleteDevices(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const std::vector<ns__Device> & requestDeviceList)
{
	struct ns__DeleteDevices *_p = soap_new_ns__DeleteDevices(soap);
	if (_p)
	{	soap_default_ns__DeleteDevices(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestDeviceList = requestDeviceList;
	}
	return _p;
}

inline struct ns__DeleteDevices * soap_new_set_ns__DeleteDevices(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const std::vector<ns__Device> & requestDeviceList)
{
	struct ns__DeleteDevices *_p = soap_new_ns__DeleteDevices(soap);
	if (_p)
	{	soap_default_ns__DeleteDevices(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestDeviceList = requestDeviceList;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DeleteDevices(struct soap*, const struct ns__DeleteDevices *, const char*, const char*);

inline int soap_write_ns__DeleteDevices(struct soap *soap, struct ns__DeleteDevices const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__DeleteDevices(soap, p), 0) || soap_put_ns__DeleteDevices(soap, p, "ns:DeleteDevices", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__DeleteDevices * SOAP_FMAC4 soap_get_ns__DeleteDevices(struct soap*, struct ns__DeleteDevices *, const char*, const char*);

inline int soap_read_ns__DeleteDevices(struct soap *soap, struct ns__DeleteDevices *p)
{
	if (p)
	{	soap_default_ns__DeleteDevices(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__DeleteDevices(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__SetAllDeviceSetting_DEFINED
#define SOAP_TYPE_ns__SetAllDeviceSetting_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetAllDeviceSetting(struct soap*, struct ns__SetAllDeviceSetting *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetAllDeviceSetting(struct soap*, const struct ns__SetAllDeviceSetting *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetAllDeviceSetting(struct soap*, const char*, int, const struct ns__SetAllDeviceSetting *, const char*);
SOAP_FMAC3 struct ns__SetAllDeviceSetting * SOAP_FMAC4 soap_in_ns__SetAllDeviceSetting(struct soap*, const char*, struct ns__SetAllDeviceSetting *, const char*);
SOAP_FMAC1 struct ns__SetAllDeviceSetting * SOAP_FMAC2 Server_Soap_instantiate_ns__SetAllDeviceSetting(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__SetAllDeviceSetting * soap_new_ns__SetAllDeviceSetting(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__SetAllDeviceSetting(soap, n, NULL, NULL, NULL);
}

inline struct ns__SetAllDeviceSetting * soap_new_req_ns__SetAllDeviceSetting(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const std::vector<ns__Device> & requestDeviceInfo)
{
	struct ns__SetAllDeviceSetting *_p = soap_new_ns__SetAllDeviceSetting(soap);
	if (_p)
	{	soap_default_ns__SetAllDeviceSetting(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestDeviceInfo = requestDeviceInfo;
	}
	return _p;
}

inline struct ns__SetAllDeviceSetting * soap_new_set_ns__SetAllDeviceSetting(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const std::vector<ns__Device> & requestDeviceInfo)
{
	struct ns__SetAllDeviceSetting *_p = soap_new_ns__SetAllDeviceSetting(soap);
	if (_p)
	{	soap_default_ns__SetAllDeviceSetting(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestDeviceInfo = requestDeviceInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetAllDeviceSetting(struct soap*, const struct ns__SetAllDeviceSetting *, const char*, const char*);

inline int soap_write_ns__SetAllDeviceSetting(struct soap *soap, struct ns__SetAllDeviceSetting const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__SetAllDeviceSetting(soap, p), 0) || soap_put_ns__SetAllDeviceSetting(soap, p, "ns:SetAllDeviceSetting", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__SetAllDeviceSetting * SOAP_FMAC4 soap_get_ns__SetAllDeviceSetting(struct soap*, struct ns__SetAllDeviceSetting *, const char*, const char*);

inline int soap_read_ns__SetAllDeviceSetting(struct soap *soap, struct ns__SetAllDeviceSetting *p)
{
	if (p)
	{	soap_default_ns__SetAllDeviceSetting(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__SetAllDeviceSetting(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__SetAllDeviceSettingResponse_DEFINED
#define SOAP_TYPE_ns__SetAllDeviceSettingResponse_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetAllDeviceSettingResponse(struct soap*, struct ns__SetAllDeviceSettingResponse *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetAllDeviceSettingResponse(struct soap*, const struct ns__SetAllDeviceSettingResponse *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetAllDeviceSettingResponse(struct soap*, const char*, int, const struct ns__SetAllDeviceSettingResponse *, const char*);
SOAP_FMAC3 struct ns__SetAllDeviceSettingResponse * SOAP_FMAC4 soap_in_ns__SetAllDeviceSettingResponse(struct soap*, const char*, struct ns__SetAllDeviceSettingResponse *, const char*);
SOAP_FMAC1 struct ns__SetAllDeviceSettingResponse * SOAP_FMAC2 Server_Soap_instantiate_ns__SetAllDeviceSettingResponse(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__SetAllDeviceSettingResponse * soap_new_ns__SetAllDeviceSettingResponse(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__SetAllDeviceSettingResponse(soap, n, NULL, NULL, NULL);
}

inline struct ns__SetAllDeviceSettingResponse * soap_new_req_ns__SetAllDeviceSettingResponse(
	struct soap *soap,
	const std::vector<ns__ErrorCode> & responseErrorInfo)
{
	struct ns__SetAllDeviceSettingResponse *_p = soap_new_ns__SetAllDeviceSettingResponse(soap);
	if (_p)
	{	soap_default_ns__SetAllDeviceSettingResponse(soap, _p);
		_p->responseErrorInfo = responseErrorInfo;
	}
	return _p;
}

inline struct ns__SetAllDeviceSettingResponse * soap_new_set_ns__SetAllDeviceSettingResponse(
	struct soap *soap,
	const std::vector<ns__ErrorCode> & responseErrorInfo)
{
	struct ns__SetAllDeviceSettingResponse *_p = soap_new_ns__SetAllDeviceSettingResponse(soap);
	if (_p)
	{	soap_default_ns__SetAllDeviceSettingResponse(soap, _p);
		_p->responseErrorInfo = responseErrorInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetAllDeviceSettingResponse(struct soap*, const struct ns__SetAllDeviceSettingResponse *, const char*, const char*);

inline int soap_write_ns__SetAllDeviceSettingResponse(struct soap *soap, struct ns__SetAllDeviceSettingResponse const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__SetAllDeviceSettingResponse(soap, p), 0) || soap_put_ns__SetAllDeviceSettingResponse(soap, p, "ns:SetAllDeviceSettingResponse", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__SetAllDeviceSettingResponse * SOAP_FMAC4 soap_get_ns__SetAllDeviceSettingResponse(struct soap*, struct ns__SetAllDeviceSettingResponse *, const char*, const char*);

inline int soap_read_ns__SetAllDeviceSettingResponse(struct soap *soap, struct ns__SetAllDeviceSettingResponse *p)
{
	if (p)
	{	soap_default_ns__SetAllDeviceSettingResponse(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__SetAllDeviceSettingResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__SetDeviceSetting_DEFINED
#define SOAP_TYPE_ns__SetDeviceSetting_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetDeviceSetting(struct soap*, struct ns__SetDeviceSetting *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetDeviceSetting(struct soap*, const struct ns__SetDeviceSetting *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetDeviceSetting(struct soap*, const char*, int, const struct ns__SetDeviceSetting *, const char*);
SOAP_FMAC3 struct ns__SetDeviceSetting * SOAP_FMAC4 soap_in_ns__SetDeviceSetting(struct soap*, const char*, struct ns__SetDeviceSetting *, const char*);
SOAP_FMAC1 struct ns__SetDeviceSetting * SOAP_FMAC2 Server_Soap_instantiate_ns__SetDeviceSetting(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__SetDeviceSetting * soap_new_ns__SetDeviceSetting(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__SetDeviceSetting(soap, n, NULL, NULL, NULL);
}

inline struct ns__SetDeviceSetting * soap_new_req_ns__SetDeviceSetting(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__Device& requestDeviceInfo)
{
	struct ns__SetDeviceSetting *_p = soap_new_ns__SetDeviceSetting(soap);
	if (_p)
	{	soap_default_ns__SetDeviceSetting(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestDeviceInfo = requestDeviceInfo;
	}
	return _p;
}

inline struct ns__SetDeviceSetting * soap_new_set_ns__SetDeviceSetting(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__Device& requestDeviceInfo)
{
	struct ns__SetDeviceSetting *_p = soap_new_ns__SetDeviceSetting(soap);
	if (_p)
	{	soap_default_ns__SetDeviceSetting(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestDeviceInfo = requestDeviceInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetDeviceSetting(struct soap*, const struct ns__SetDeviceSetting *, const char*, const char*);

inline int soap_write_ns__SetDeviceSetting(struct soap *soap, struct ns__SetDeviceSetting const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__SetDeviceSetting(soap, p), 0) || soap_put_ns__SetDeviceSetting(soap, p, "ns:SetDeviceSetting", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__SetDeviceSetting * SOAP_FMAC4 soap_get_ns__SetDeviceSetting(struct soap*, struct ns__SetDeviceSetting *, const char*, const char*);

inline int soap_read_ns__SetDeviceSetting(struct soap *soap, struct ns__SetDeviceSetting *p)
{
	if (p)
	{	soap_default_ns__SetDeviceSetting(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__SetDeviceSetting(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__GetDevicePicturePart_DEFINED
#define SOAP_TYPE_ns__GetDevicePicturePart_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetDevicePicturePart(struct soap*, struct ns__GetDevicePicturePart *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetDevicePicturePart(struct soap*, const struct ns__GetDevicePicturePart *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetDevicePicturePart(struct soap*, const char*, int, const struct ns__GetDevicePicturePart *, const char*);
SOAP_FMAC3 struct ns__GetDevicePicturePart * SOAP_FMAC4 soap_in_ns__GetDevicePicturePart(struct soap*, const char*, struct ns__GetDevicePicturePart *, const char*);
SOAP_FMAC1 struct ns__GetDevicePicturePart * SOAP_FMAC2 Server_Soap_instantiate_ns__GetDevicePicturePart(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__GetDevicePicturePart * soap_new_ns__GetDevicePicturePart(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__GetDevicePicturePart(soap, n, NULL, NULL, NULL);
}

inline struct ns__GetDevicePicturePart * soap_new_req_ns__GetDevicePicturePart(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__Device& requestDeviceInfo)
{
	struct ns__GetDevicePicturePart *_p = soap_new_ns__GetDevicePicturePart(soap);
	if (_p)
	{	soap_default_ns__GetDevicePicturePart(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestDeviceInfo = requestDeviceInfo;
	}
	return _p;
}

inline struct ns__GetDevicePicturePart * soap_new_set_ns__GetDevicePicturePart(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__Device& requestDeviceInfo)
{
	struct ns__GetDevicePicturePart *_p = soap_new_ns__GetDevicePicturePart(soap);
	if (_p)
	{	soap_default_ns__GetDevicePicturePart(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestDeviceInfo = requestDeviceInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetDevicePicturePart(struct soap*, const struct ns__GetDevicePicturePart *, const char*, const char*);

inline int soap_write_ns__GetDevicePicturePart(struct soap *soap, struct ns__GetDevicePicturePart const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__GetDevicePicturePart(soap, p), 0) || soap_put_ns__GetDevicePicturePart(soap, p, "ns:GetDevicePicturePart", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__GetDevicePicturePart * SOAP_FMAC4 soap_get_ns__GetDevicePicturePart(struct soap*, struct ns__GetDevicePicturePart *, const char*, const char*);

inline int soap_read_ns__GetDevicePicturePart(struct soap *soap, struct ns__GetDevicePicturePart *p)
{
	if (p)
	{	soap_default_ns__GetDevicePicturePart(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__GetDevicePicturePart(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__GetDevicePicture_DEFINED
#define SOAP_TYPE_ns__GetDevicePicture_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetDevicePicture(struct soap*, struct ns__GetDevicePicture *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetDevicePicture(struct soap*, const struct ns__GetDevicePicture *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetDevicePicture(struct soap*, const char*, int, const struct ns__GetDevicePicture *, const char*);
SOAP_FMAC3 struct ns__GetDevicePicture * SOAP_FMAC4 soap_in_ns__GetDevicePicture(struct soap*, const char*, struct ns__GetDevicePicture *, const char*);
SOAP_FMAC1 struct ns__GetDevicePicture * SOAP_FMAC2 Server_Soap_instantiate_ns__GetDevicePicture(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__GetDevicePicture * soap_new_ns__GetDevicePicture(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__GetDevicePicture(soap, n, NULL, NULL, NULL);
}

inline struct ns__GetDevicePicture * soap_new_req_ns__GetDevicePicture(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__Device& requestDeviceInfo)
{
	struct ns__GetDevicePicture *_p = soap_new_ns__GetDevicePicture(soap);
	if (_p)
	{	soap_default_ns__GetDevicePicture(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestDeviceInfo = requestDeviceInfo;
	}
	return _p;
}

inline struct ns__GetDevicePicture * soap_new_set_ns__GetDevicePicture(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__Device& requestDeviceInfo)
{
	struct ns__GetDevicePicture *_p = soap_new_ns__GetDevicePicture(soap);
	if (_p)
	{	soap_default_ns__GetDevicePicture(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestDeviceInfo = requestDeviceInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetDevicePicture(struct soap*, const struct ns__GetDevicePicture *, const char*, const char*);

inline int soap_write_ns__GetDevicePicture(struct soap *soap, struct ns__GetDevicePicture const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__GetDevicePicture(soap, p), 0) || soap_put_ns__GetDevicePicture(soap, p, "ns:GetDevicePicture", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__GetDevicePicture * SOAP_FMAC4 soap_get_ns__GetDevicePicture(struct soap*, struct ns__GetDevicePicture *, const char*, const char*);

inline int soap_read_ns__GetDevicePicture(struct soap *soap, struct ns__GetDevicePicture *p)
{
	if (p)
	{	soap_default_ns__GetDevicePicture(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__GetDevicePicture(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__GetAllDeviceStatus_DEFINED
#define SOAP_TYPE_ns__GetAllDeviceStatus_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllDeviceStatus(struct soap*, struct ns__GetAllDeviceStatus *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllDeviceStatus(struct soap*, const struct ns__GetAllDeviceStatus *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllDeviceStatus(struct soap*, const char*, int, const struct ns__GetAllDeviceStatus *, const char*);
SOAP_FMAC3 struct ns__GetAllDeviceStatus * SOAP_FMAC4 soap_in_ns__GetAllDeviceStatus(struct soap*, const char*, struct ns__GetAllDeviceStatus *, const char*);
SOAP_FMAC1 struct ns__GetAllDeviceStatus * SOAP_FMAC2 Server_Soap_instantiate_ns__GetAllDeviceStatus(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__GetAllDeviceStatus * soap_new_ns__GetAllDeviceStatus(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__GetAllDeviceStatus(soap, n, NULL, NULL, NULL);
}

inline struct ns__GetAllDeviceStatus * soap_new_req_ns__GetAllDeviceStatus(
	struct soap *soap,
	const ns__User& requestUserInfo)
{
	struct ns__GetAllDeviceStatus *_p = soap_new_ns__GetAllDeviceStatus(soap);
	if (_p)
	{	soap_default_ns__GetAllDeviceStatus(soap, _p);
		_p->requestUserInfo = requestUserInfo;
	}
	return _p;
}

inline struct ns__GetAllDeviceStatus * soap_new_set_ns__GetAllDeviceStatus(
	struct soap *soap,
	const ns__User& requestUserInfo)
{
	struct ns__GetAllDeviceStatus *_p = soap_new_ns__GetAllDeviceStatus(soap);
	if (_p)
	{	soap_default_ns__GetAllDeviceStatus(soap, _p);
		_p->requestUserInfo = requestUserInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllDeviceStatus(struct soap*, const struct ns__GetAllDeviceStatus *, const char*, const char*);

inline int soap_write_ns__GetAllDeviceStatus(struct soap *soap, struct ns__GetAllDeviceStatus const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__GetAllDeviceStatus(soap, p), 0) || soap_put_ns__GetAllDeviceStatus(soap, p, "ns:GetAllDeviceStatus", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__GetAllDeviceStatus * SOAP_FMAC4 soap_get_ns__GetAllDeviceStatus(struct soap*, struct ns__GetAllDeviceStatus *, const char*, const char*);

inline int soap_read_ns__GetAllDeviceStatus(struct soap *soap, struct ns__GetAllDeviceStatus *p)
{
	if (p)
	{	soap_default_ns__GetAllDeviceStatus(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__GetAllDeviceStatus(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__GetDeviceStatus_DEFINED
#define SOAP_TYPE_ns__GetDeviceStatus_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetDeviceStatus(struct soap*, struct ns__GetDeviceStatus *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetDeviceStatus(struct soap*, const struct ns__GetDeviceStatus *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetDeviceStatus(struct soap*, const char*, int, const struct ns__GetDeviceStatus *, const char*);
SOAP_FMAC3 struct ns__GetDeviceStatus * SOAP_FMAC4 soap_in_ns__GetDeviceStatus(struct soap*, const char*, struct ns__GetDeviceStatus *, const char*);
SOAP_FMAC1 struct ns__GetDeviceStatus * SOAP_FMAC2 Server_Soap_instantiate_ns__GetDeviceStatus(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__GetDeviceStatus * soap_new_ns__GetDeviceStatus(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_ns__GetDeviceStatus(soap, n, NULL, NULL, NULL);
}

inline struct ns__GetDeviceStatus * soap_new_req_ns__GetDeviceStatus(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__Device& requestDeviceInfo)
{
	struct ns__GetDeviceStatus *_p = soap_new_ns__GetDeviceStatus(soap);
	if (_p)
	{	soap_default_ns__GetDeviceStatus(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestDeviceInfo = requestDeviceInfo;
	}
	return _p;
}

inline struct ns__GetDeviceStatus * soap_new_set_ns__GetDeviceStatus(
	struct soap *soap,
	const ns__User& requestUserInfo,
	const ns__Device& requestDeviceInfo)
{
	struct ns__GetDeviceStatus *_p = soap_new_ns__GetDeviceStatus(soap);
	if (_p)
	{	soap_default_ns__GetDeviceStatus(soap, _p);
		_p->requestUserInfo = requestUserInfo;
		_p->requestDeviceInfo = requestDeviceInfo;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetDeviceStatus(struct soap*, const struct ns__GetDeviceStatus *, const char*, const char*);

inline int soap_write_ns__GetDeviceStatus(struct soap *soap, struct ns__GetDeviceStatus const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__GetDeviceStatus(soap, p), 0) || soap_put_ns__GetDeviceStatus(soap, p, "ns:GetDeviceStatus", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__GetDeviceStatus * SOAP_FMAC4 soap_get_ns__GetDeviceStatus(struct soap*, struct ns__GetDeviceStatus *, const char*, const char*);

inline int soap_read_ns__GetDeviceStatus(struct soap *soap, struct ns__GetDeviceStatus *p)
{
	if (p)
	{	soap_default_ns__GetDeviceStatus(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__GetDeviceStatus(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Reason_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap*, const char *, int, struct SOAP_ENV__Reason *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason **, const char*, const char*);
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Detail_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap*, const char *, int, struct SOAP_ENV__Detail *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail **, const char*, const char*);
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Code_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap*, const char *, int, struct SOAP_ENV__Code *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code **, const char*, const char*);
#endif

#endif

#ifndef SOAP_TYPE__XML_DEFINED
#define SOAP_TYPE__XML_DEFINED
#endif

#ifndef SOAP_TYPE__QName_DEFINED
#define SOAP_TYPE__QName_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap*, char **);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap*, char *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap*, const char*, int, char*const*, const char*);
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap*, const char*, char **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap*, char *const*, const char*, const char*);

inline int soap_write__QName(struct soap *soap, char *const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put__QName(soap, p, "QName", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap*, char **, const char*, const char*);

inline int soap_read__QName(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get__QName(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_string_DEFINED
#define SOAP_TYPE_string_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap*, char **);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap*, char *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap*, const char*, int, char*const*, const char*);
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap*, const char*, char **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap*, char *const*, const char*, const char*);

inline int soap_write_string(struct soap *soap, char *const *p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_string(soap, p, "string", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap*, char **, const char*, const char*);

inline int soap_read_string(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_string(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfns__UserLog_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfns__UserLog_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__UserLog(struct soap*, std::vector<ns__UserLog> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__UserLog(struct soap*, const std::vector<ns__UserLog> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__UserLog(struct soap*, const char*, int, const std::vector<ns__UserLog> *, const char*);
SOAP_FMAC3 std::vector<ns__UserLog> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__UserLog(struct soap*, const char*, std::vector<ns__UserLog> *, const char*);
SOAP_FMAC1 std::vector<ns__UserLog>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfns__UserLog(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<ns__UserLog>  * soap_new_std__vectorTemplateOfns__UserLog(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfns__UserLog(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfns__ActivityLog_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfns__ActivityLog_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__ActivityLog(struct soap*, std::vector<ns__ActivityLog> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__ActivityLog(struct soap*, const std::vector<ns__ActivityLog> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__ActivityLog(struct soap*, const char*, int, const std::vector<ns__ActivityLog> *, const char*);
SOAP_FMAC3 std::vector<ns__ActivityLog> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__ActivityLog(struct soap*, const char*, std::vector<ns__ActivityLog> *, const char*);
SOAP_FMAC1 std::vector<ns__ActivityLog>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfns__ActivityLog(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<ns__ActivityLog>  * soap_new_std__vectorTemplateOfns__ActivityLog(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfns__ActivityLog(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfns__ErrorCode_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfns__ErrorCode_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__ErrorCode(struct soap*, std::vector<ns__ErrorCode> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__ErrorCode(struct soap*, const std::vector<ns__ErrorCode> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__ErrorCode(struct soap*, const char*, int, const std::vector<ns__ErrorCode> *, const char*);
SOAP_FMAC3 std::vector<ns__ErrorCode> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__ErrorCode(struct soap*, const char*, std::vector<ns__ErrorCode> *, const char*);
SOAP_FMAC1 std::vector<ns__ErrorCode>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfns__ErrorCode(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<ns__ErrorCode>  * soap_new_std__vectorTemplateOfns__ErrorCode(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfns__ErrorCode(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfns__CityLocation_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfns__CityLocation_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__CityLocation(struct soap*, std::vector<ns__CityLocation> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__CityLocation(struct soap*, const std::vector<ns__CityLocation> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__CityLocation(struct soap*, const char*, int, const std::vector<ns__CityLocation> *, const char*);
SOAP_FMAC3 std::vector<ns__CityLocation> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__CityLocation(struct soap*, const char*, std::vector<ns__CityLocation> *, const char*);
SOAP_FMAC1 std::vector<ns__CityLocation>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfns__CityLocation(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<ns__CityLocation>  * soap_new_std__vectorTemplateOfns__CityLocation(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfns__CityLocation(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__string_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxsd__string_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__string(struct soap*, std::vector<std::string> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__string(struct soap*, const std::vector<std::string> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__string(struct soap*, const char*, int, const std::vector<std::string> *, const char*);
SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__string(struct soap*, const char*, std::vector<std::string> *, const char*);
SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfxsd__string(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<std::string>  * soap_new_std__vectorTemplateOfxsd__string(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfxsd__string(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfns__DeviceRules_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfns__DeviceRules_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__DeviceRules(struct soap*, std::vector<ns__DeviceRules> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__DeviceRules(struct soap*, const std::vector<ns__DeviceRules> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__DeviceRules(struct soap*, const char*, int, const std::vector<ns__DeviceRules> *, const char*);
SOAP_FMAC3 std::vector<ns__DeviceRules> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__DeviceRules(struct soap*, const char*, std::vector<ns__DeviceRules> *, const char*);
SOAP_FMAC1 std::vector<ns__DeviceRules>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfns__DeviceRules(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<ns__DeviceRules>  * soap_new_std__vectorTemplateOfns__DeviceRules(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfns__DeviceRules(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfstd__string_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap*, std::vector<std::string> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap*, const std::vector<std::string> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap*, const char*, int, const std::vector<std::string> *, const char*);
SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap*, const char*, std::vector<std::string> *, const char*);
SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfstd__string(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<std::string>  * soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfns__Device_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfns__Device_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__Device(struct soap*, std::vector<ns__Device> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__Device(struct soap*, const std::vector<ns__Device> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__Device(struct soap*, const char*, int, const std::vector<ns__Device> *, const char*);
SOAP_FMAC3 std::vector<ns__Device> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__Device(struct soap*, const char*, std::vector<ns__Device> *, const char*);
SOAP_FMAC1 std::vector<ns__Device>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfns__Device(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<ns__Device>  * soap_new_std__vectorTemplateOfns__Device(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfns__Device(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__DeviceStatusLog(struct soap*, std::vector<ns__DeviceStatusLog> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__DeviceStatusLog(struct soap*, const std::vector<ns__DeviceStatusLog> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__DeviceStatusLog(struct soap*, const char*, int, const std::vector<ns__DeviceStatusLog> *, const char*);
SOAP_FMAC3 std::vector<ns__DeviceStatusLog> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__DeviceStatusLog(struct soap*, const char*, std::vector<ns__DeviceStatusLog> *, const char*);
SOAP_FMAC1 std::vector<ns__DeviceStatusLog>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfns__DeviceStatusLog(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<ns__DeviceStatusLog>  * soap_new_std__vectorTemplateOfns__DeviceStatusLog(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfns__DeviceStatusLog(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfns__SensorExtension_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfns__SensorExtension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__SensorExtension(struct soap*, std::vector<ns__SensorExtension> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__SensorExtension(struct soap*, const std::vector<ns__SensorExtension> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__SensorExtension(struct soap*, const char*, int, const std::vector<ns__SensorExtension> *, const char*);
SOAP_FMAC3 std::vector<ns__SensorExtension> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__SensorExtension(struct soap*, const char*, std::vector<ns__SensorExtension> *, const char*);
SOAP_FMAC1 std::vector<ns__SensorExtension>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfns__SensorExtension(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<ns__SensorExtension>  * soap_new_std__vectorTemplateOfns__SensorExtension(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfns__SensorExtension(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfns__Request_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfns__Request_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__Request(struct soap*, std::vector<ns__Request> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__Request(struct soap*, const std::vector<ns__Request> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__Request(struct soap*, const char*, int, const std::vector<ns__Request> *, const char*);
SOAP_FMAC3 std::vector<ns__Request> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__Request(struct soap*, const char*, std::vector<ns__Request> *, const char*);
SOAP_FMAC1 std::vector<ns__Request>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfns__Request(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<ns__Request>  * soap_new_std__vectorTemplateOfns__Request(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfns__Request(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__boolean_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxsd__boolean_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__boolean(struct soap*, std::vector<bool> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__boolean(struct soap*, const std::vector<bool> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__boolean(struct soap*, const char*, int, const std::vector<bool> *, const char*);
SOAP_FMAC3 std::vector<bool> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__boolean(struct soap*, const char*, std::vector<bool> *, const char*);
SOAP_FMAC1 std::vector<bool>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfxsd__boolean(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<bool>  * soap_new_std__vectorTemplateOfxsd__boolean(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfxsd__boolean(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__long_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxsd__long_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__long(struct soap*, std::vector<LONG64> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__long(struct soap*, const std::vector<LONG64> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__long(struct soap*, const char*, int, const std::vector<LONG64> *, const char*);
SOAP_FMAC3 std::vector<LONG64> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__long(struct soap*, const char*, std::vector<LONG64> *, const char*);
SOAP_FMAC1 std::vector<LONG64>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfxsd__long(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<LONG64>  * soap_new_std__vectorTemplateOfxsd__long(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfxsd__long(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfns__PicturePart_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfns__PicturePart_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__PicturePart(struct soap*, std::vector<ns__PicturePart> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__PicturePart(struct soap*, const std::vector<ns__PicturePart> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__PicturePart(struct soap*, const char*, int, const std::vector<ns__PicturePart> *, const char*);
SOAP_FMAC3 std::vector<ns__PicturePart> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__PicturePart(struct soap*, const char*, std::vector<ns__PicturePart> *, const char*);
SOAP_FMAC1 std::vector<ns__PicturePart>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfns__PicturePart(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<ns__PicturePart>  * soap_new_std__vectorTemplateOfns__PicturePart(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfns__PicturePart(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfns__Sensor_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfns__Sensor_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__Sensor(struct soap*, std::vector<ns__Sensor> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__Sensor(struct soap*, const std::vector<ns__Sensor> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__Sensor(struct soap*, const char*, int, const std::vector<ns__Sensor> *, const char*);
SOAP_FMAC3 std::vector<ns__Sensor> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__Sensor(struct soap*, const char*, std::vector<ns__Sensor> *, const char*);
SOAP_FMAC1 std::vector<ns__Sensor>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfns__Sensor(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<ns__Sensor>  * soap_new_std__vectorTemplateOfns__Sensor(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfns__Sensor(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfns__User_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfns__User_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__User(struct soap*, std::vector<ns__User> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__User(struct soap*, const std::vector<ns__User> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__User(struct soap*, const char*, int, const std::vector<ns__User> *, const char*);
SOAP_FMAC3 std::vector<ns__User> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__User(struct soap*, const char*, std::vector<ns__User> *, const char*);
SOAP_FMAC1 std::vector<ns__User>  * SOAP_FMAC2 Server_Soap_instantiate_std__vectorTemplateOfns__User(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<ns__User>  * soap_new_std__vectorTemplateOfns__User(struct soap *soap, int n = -1)
{
	return Server_Soap_instantiate_std__vectorTemplateOfns__User(soap, n, NULL, NULL, NULL);
}
#endif

#endif

/* End of Server_SoapH.h */

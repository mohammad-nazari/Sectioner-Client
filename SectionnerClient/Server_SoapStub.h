/* Server_SoapStub.h
   Generated by gSOAP 2.8.31 for F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>

#ifndef Server_SoapStub_H
#define Server_SoapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20831
# error "GSOAP VERSION 20831 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:17 */
#ifndef SOAP_TYPE_ns__SettingLevel
#define SOAP_TYPE_ns__SettingLevel (20)
/* ns:SettingLevel */
enum ns__SettingLevel {
	Normal = 0,
	Disable = 1,
	Warning = 2,
	Minor = 3,
	Major = 4,
	Critical = 5
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:27 */
#ifndef SOAP_TYPE_ns__UserType
#define SOAP_TYPE_ns__UserType (21)
/* ns:UserType */
enum ns__UserType {
	Admin = 0,
	Control = 1,
	Monitor = 2
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:34 */
#ifndef SOAP_TYPE_ns__SimcardType
#define SOAP_TYPE_ns__SimcardType (22)
/* ns:SimcardType */
enum ns__SimcardType {
	MCI = 0,
	IranCell = 1,
	Taliya = 2,
	RighTel = 3,
	UnknownSim = 4
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:43 */
#ifndef SOAP_TYPE_ns__SensorType
#define SOAP_TYPE_ns__SensorType (23)
/* ns:SensorType */
enum ns__SensorType {
	Multi = 0,
	Mono = 1
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:49 */
#ifndef SOAP_TYPE_ns__SensorName
#define SOAP_TYPE_ns__SensorName (24)
/* ns:SensorName */
enum ns__SensorName {
	TEMPERATURE = 0,
	HUMIDITY = 1,
	ACVOLTAGE = 2,
	ACAMPERE = 3,
	DCVOLTAGE = 4,
	DCAMPERE = 5,
	COSQ = 6,
	DIGITALINPUT = 7,
	DIGITALOUTPUT = 8,
	DIGITALEXIST = 9,
	RELAY = 10,
	UNKNOWN = 11
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:65 */
#ifndef SOAP_TYPE_ns__DeviceModel
#define SOAP_TYPE_ns__DeviceModel (25)
/* ns:DeviceModel */
enum ns__DeviceModel {
	PROTECTOR = 0,
	SECTIONNER = 1,
	TRANSISTOR = 2,
	SERVER = 3,
	MANAGER = 4,
	ROBER = 5
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:75 */
#ifndef SOAP_TYPE_ns__RequestType
#define SOAP_TYPE_ns__RequestType (26)
/* ns:RequestType */
enum ns__RequestType {
	CALIBRATION = 0,
	SAMPLING = 1,
	OUTRELAY = 2,
	DATETIME = 3,
	PICTURE = 4,
	PARTS = 5,
	RESET = 6,
	LIVE = 7,
	OK = 8,
	DATA = 9
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:89 */
#ifndef SOAP_TYPE_ns__KeyType
#define SOAP_TYPE_ns__KeyType (27)
/* ns:KeyType */
enum ns__KeyType {
	AAAA = 0,
	BBBB = 1,
	CCCC = 2
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class ns__ErrorCode;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:96 */
class ns__User;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:103 */
class ns__UsersList;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:117 */
class ns__IP;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:123 */
class ns__Server;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:131 */
class ns__Gprs;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:139 */
class ns__GPS;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:147 */
class ns__Mobile;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:153 */
class ns__Relay;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:161 */
class ns__Sensor;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:167 */
class ns__SensorExtension;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:184 */
class ns__Camera;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:190 */
class ns__PicturePart;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:199 */
class ns__Picture;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:206 */
class ns__Request;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:215 */
class ns__Device;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:220 */
class ns__ReportRange;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:258 */
class ns__ActivityLog;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:264 */
class ns__UserLog;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:273 */
class ns__DeviceStatusLog;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:281 */
class ns__DeviceStatusLogList;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:288 */
class ns__DeviceStatusInfo;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:295 */
class ns__ErrorLog;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:302 */
class ns__DeviceRules;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:310 */
class ns__UserDevices;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:318 */
class ns__UserDevice;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:324 */
class ns__DataBaseInfo;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:331 */
class ns__ServerOptions;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:340 */
class ns__CityLocation;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:347 */
class ns__AllCityLocatoins;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:354 */
struct ns__GetDeviceStatus;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:362 */
struct ns__GetAllDeviceStatus;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:365 */
struct ns__GetDevicePicture;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:368 */
struct ns__GetDevicePicturePart;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:371 */
struct ns__SetDeviceSetting;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:374 */
struct ns__SetAllDeviceSettingResponse;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:377 */
struct ns__SetAllDeviceSetting;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:377 */
struct ns__DeleteDevices;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:380 */
struct ns__Login;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:384 */
struct ns__GetUserDeviceList;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:387 */
struct ns__GetUsersList;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:391 */
struct ns__AddUser;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:394 */
struct ns__UpdateUser;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:397 */
struct ns__DeleteUser;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:400 */
struct ns__AssignDeviceToUser;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:403 */
struct ns__DeleteDeviceFromUser;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:406 */
struct ns__GetUserDevices;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:409 */
struct ns__SaveActivityLog;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:413 */
struct ns__GetActivityLogResponse;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:416 */
struct ns__GetActivityLog;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:416 */
struct ns__SaveUserLog;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:419 */
struct ns__GetUserLogResponse;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:422 */
struct ns__GetUserLog;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:422 */
struct ns__SaveDeviceStatusLog;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:425 */
struct ns__GetDeviceStatusLog;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:428 */
struct ns__GetServerOptions;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:432 */
struct ns__SetServerOptions;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:435 */
struct ns__GetCityAndLocations;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:439 */
struct ns__ChangeCityName;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:442 */
struct ns__ChangeLocationName;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:445 */
struct ns__ChangeDeviceName;	/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:448 */

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:96 */
#ifndef SOAP_TYPE_ns__ErrorCode
#define SOAP_TYPE_ns__ErrorCode (28)
/* complex XSD type 'ns:ErrorCode': */
class SOAP_CMAC ns__ErrorCode {
      public:
        /// Optional element 'errorNumber' of XSD type 'xsd:int'
        int errorNumber;	///< default = 0
        /// Optional element 'errorMessage' of XSD type 'xsd:string'
        std::string errorMessage;	///< default = ""
        /// Optional element 'errorType' of XSD type 'ns:SettingLevel'
        enum ns__SettingLevel errorType;	///< default = (enum ns__SettingLevel)0
      public:
        /// Return unique type id SOAP_TYPE_ns__ErrorCode
        virtual int soap_type(void) const { return SOAP_TYPE_ns__ErrorCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__ErrorCode, default initialized and not managed by a soap context
        virtual ns__ErrorCode *soap_alloc(void) const { return SOAP_NEW(ns__ErrorCode); }
      public:
        /// Constructor with initializations
        ns__ErrorCode()
        {
          errorNumber = 0;
          errorMessage = "";
          errorType = (enum ns__SettingLevel)0;
        }
        virtual ~ns__ErrorCode() { }
        /// Friend allocator used by soap_new_ns__ErrorCode(struct soap*, int)
        friend SOAP_FMAC1 ns__ErrorCode * SOAP_FMAC2 Server_Soap_instantiate_ns__ErrorCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:103 */
#ifndef SOAP_TYPE_ns__User
#define SOAP_TYPE_ns__User (29)
/* complex XSD type 'ns:User': */
class SOAP_CMAC ns__User {
      public:
        /// Optional element 'userId' of XSD type 'xsd:int'
        int userId;	///< default = 0
        /// Optional element 'userName' of XSD type 'xsd:string'
        std::string userName;	///< default = ""
        /// Optional element 'userPassword' of XSD type 'xsd:string'
        std::string userPassword;	///< default = ""
        /// Optional element 'userNewPassword' of XSD type 'xsd:string'
        std::string userNewPassword;	///< default = ""
        /// Optional element 'userFirstName' of XSD type 'xsd:string'
        std::string userFirstName;	///< default = ""
        /// Optional element 'userLastName' of XSD type 'xsd:string'
        std::string userLastName;	///< default = ""
        /// Optional element 'userType' of XSD type 'ns:UserType'
        enum ns__UserType userType;	///< default = (enum ns__UserType)2
        /// Optional element 'userKey' of XSD type 'xsd:string'
        std::string userKey;	///< default = ""
        /// Required element 'userSubmit' of XSD type 'xsd:dateTime'
        time_t userSubmit;
        /// Required element 'userError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode userError;
      public:
        /// Return unique type id SOAP_TYPE_ns__User
        virtual int soap_type(void) const { return SOAP_TYPE_ns__User; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__User, default initialized and not managed by a soap context
        virtual ns__User *soap_alloc(void) const { return SOAP_NEW(ns__User); }
      public:
        /// Constructor with initializations
        ns__User()
        {
          userId = 0;
          userName = "";
          userPassword = "";
          userNewPassword = "";
          userFirstName = "";
          userLastName = "";
          userType = (enum ns__UserType)2;
          userKey = "";
          userSubmit = (time_t)0;
        }
        virtual ~ns__User() { }
        /// Friend allocator used by soap_new_ns__User(struct soap*, int)
        friend SOAP_FMAC1 ns__User * SOAP_FMAC2 Server_Soap_instantiate_ns__User(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:117 */
#ifndef SOAP_TYPE_ns__UsersList
#define SOAP_TYPE_ns__UsersList (30)
/* complex XSD type 'ns:UsersList': */
class SOAP_CMAC ns__UsersList {
      public:
        /// Optional element 'usersListUsers' of XSD type 'ns:User'
        std::vector<ns__User> usersListUsers;
        /// Required element 'usersListError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode usersListError;
      public:
        /// Return unique type id SOAP_TYPE_ns__UsersList
        virtual int soap_type(void) const { return SOAP_TYPE_ns__UsersList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__UsersList, default initialized and not managed by a soap context
        virtual ns__UsersList *soap_alloc(void) const { return SOAP_NEW(ns__UsersList); }
      public:
        /// Constructor with initializations
        ns__UsersList()
        {
        }
        virtual ~ns__UsersList() { }
        /// Friend allocator used by soap_new_ns__UsersList(struct soap*, int)
        friend SOAP_FMAC1 ns__UsersList * SOAP_FMAC2 Server_Soap_instantiate_ns__UsersList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:123 */
#ifndef SOAP_TYPE_ns__IP
#define SOAP_TYPE_ns__IP (32)
/* complex XSD type 'ns:IP': */
class SOAP_CMAC ns__IP {
      public:
        /// Optional element 'ip1' of XSD type 'xsd:int'
        int ip1;	///< default = 0
        /// Optional element 'ip2' of XSD type 'xsd:int'
        int ip2;	///< default = 0
        /// Optional element 'ip3' of XSD type 'xsd:int'
        int ip3;	///< default = 0
        /// Optional element 'ip4' of XSD type 'xsd:int'
        int ip4;	///< default = 0
      public:
        /// Return unique type id SOAP_TYPE_ns__IP
        virtual int soap_type(void) const { return SOAP_TYPE_ns__IP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__IP, default initialized and not managed by a soap context
        virtual ns__IP *soap_alloc(void) const { return SOAP_NEW(ns__IP); }
      public:
        /// Constructor with initializations
        ns__IP()
        {
          ip1 = 0;
          ip2 = 0;
          ip3 = 0;
          ip4 = 0;
        }
        virtual ~ns__IP() { }
        /// Friend allocator used by soap_new_ns__IP(struct soap*, int)
        friend SOAP_FMAC1 ns__IP * SOAP_FMAC2 Server_Soap_instantiate_ns__IP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:131 */
#ifndef SOAP_TYPE_ns__Server
#define SOAP_TYPE_ns__Server (33)
/* complex XSD type 'ns:Server': */
class SOAP_CMAC ns__Server {
      public:
        /// Required element 'serverDNSAddress' of XSD type 'xsd:string'
        std::string serverDNSAddress;
        /// Required element 'serverIP' of XSD type 'ns:IP'
        ns__IP serverIP;
        /// Optional element 'serverPort' of XSD type 'xsd:int'
        int serverPort;	///< default = 0
        /// Required element 'serverError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode serverError;
      public:
        /// Return unique type id SOAP_TYPE_ns__Server
        virtual int soap_type(void) const { return SOAP_TYPE_ns__Server; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__Server, default initialized and not managed by a soap context
        virtual ns__Server *soap_alloc(void) const { return SOAP_NEW(ns__Server); }
      public:
        /// Constructor with initializations
        ns__Server()
        {
          serverPort = 0;
        }
        virtual ~ns__Server() { }
        /// Friend allocator used by soap_new_ns__Server(struct soap*, int)
        friend SOAP_FMAC1 ns__Server * SOAP_FMAC2 Server_Soap_instantiate_ns__Server(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:139 */
#ifndef SOAP_TYPE_ns__Gprs
#define SOAP_TYPE_ns__Gprs (34)
/* complex XSD type 'ns:Gprs': */
class SOAP_CMAC ns__Gprs {
      public:
        /// Required element 'gprsDNSAddress' of XSD type 'xsd:string'
        std::string gprsDNSAddress;
        /// Required element 'gprsIP' of XSD type 'ns:IP'
        ns__IP gprsIP;
        /// Optional element 'gprsPort' of XSD type 'xsd:int'
        int gprsPort;	///< default = 0
        /// Required element 'gprsError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode gprsError;
      public:
        /// Return unique type id SOAP_TYPE_ns__Gprs
        virtual int soap_type(void) const { return SOAP_TYPE_ns__Gprs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__Gprs, default initialized and not managed by a soap context
        virtual ns__Gprs *soap_alloc(void) const { return SOAP_NEW(ns__Gprs); }
      public:
        /// Constructor with initializations
        ns__Gprs()
        {
          gprsPort = 0;
        }
        virtual ~ns__Gprs() { }
        /// Friend allocator used by soap_new_ns__Gprs(struct soap*, int)
        friend SOAP_FMAC1 ns__Gprs * SOAP_FMAC2 Server_Soap_instantiate_ns__Gprs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:147 */
#ifndef SOAP_TYPE_ns__GPS
#define SOAP_TYPE_ns__GPS (35)
/* complex XSD type 'ns:GPS': */
class SOAP_CMAC ns__GPS {
      public:
        /// Optional element 'gpsX' of XSD type 'xsd:double'
        double gpsX;	///< default = 0
        /// Optional element 'gpsY' of XSD type 'xsd:double'
        double gpsY;	///< default = 0
      public:
        /// Return unique type id SOAP_TYPE_ns__GPS
        virtual int soap_type(void) const { return SOAP_TYPE_ns__GPS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__GPS, default initialized and not managed by a soap context
        virtual ns__GPS *soap_alloc(void) const { return SOAP_NEW(ns__GPS); }
      public:
        /// Constructor with initializations
        ns__GPS()
        {
          gpsX = 0;
          gpsY = 0;
        }
        virtual ~ns__GPS() { }
        /// Friend allocator used by soap_new_ns__GPS(struct soap*, int)
        friend SOAP_FMAC1 ns__GPS * SOAP_FMAC2 Server_Soap_instantiate_ns__GPS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:153 */
#ifndef SOAP_TYPE_ns__Mobile
#define SOAP_TYPE_ns__Mobile (36)
/* complex XSD type 'ns:Mobile': */
class SOAP_CMAC ns__Mobile {
      public:
        /// Optional element 'mobileNumber' of XSD type 'xsd:long'
        LONG64 mobileNumber;	///< default = 0LL
        /// Optional element 'mobileSimCardType' of XSD type 'ns:SimcardType'
        enum ns__SimcardType mobileSimCardType;	///< default = (enum ns__SimcardType)0
        /// Optional element 'mobileChargeValue' of XSD type 'xsd:int'
        int mobileChargeValue;	///< default = 0
        /// Optional element 'mobileSignalValue' of XSD type 'xsd:int'
        int mobileSignalValue;	///< default = 0
      public:
        /// Return unique type id SOAP_TYPE_ns__Mobile
        virtual int soap_type(void) const { return SOAP_TYPE_ns__Mobile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__Mobile, default initialized and not managed by a soap context
        virtual ns__Mobile *soap_alloc(void) const { return SOAP_NEW(ns__Mobile); }
      public:
        /// Constructor with initializations
        ns__Mobile()
        {
          mobileNumber = 0LL;
          mobileSimCardType = (enum ns__SimcardType)0;
          mobileChargeValue = 0;
          mobileSignalValue = 0;
        }
        virtual ~ns__Mobile() { }
        /// Friend allocator used by soap_new_ns__Mobile(struct soap*, int)
        friend SOAP_FMAC1 ns__Mobile * SOAP_FMAC2 Server_Soap_instantiate_ns__Mobile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:161 */
#ifndef SOAP_TYPE_ns__Relay
#define SOAP_TYPE_ns__Relay (37)
/* complex XSD type 'ns:Relay': */
class SOAP_CMAC ns__Relay {
      public:
        /// Optional element 'relayIndex' of XSD type 'xsd:int'
        int relayIndex;	///< default = 0
        /// Optional element 'relayOnOff' of XSD type 'xsd:boolean'
        bool relayOnOff;	///< default = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_ns__Relay
        virtual int soap_type(void) const { return SOAP_TYPE_ns__Relay; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__Relay, default initialized and not managed by a soap context
        virtual ns__Relay *soap_alloc(void) const { return SOAP_NEW(ns__Relay); }
      public:
        /// Constructor with initializations
        ns__Relay()
        {
          relayIndex = 0;
          relayOnOff = (bool)0;
        }
        virtual ~ns__Relay() { }
        /// Friend allocator used by soap_new_ns__Relay(struct soap*, int)
        friend SOAP_FMAC1 ns__Relay * SOAP_FMAC2 Server_Soap_instantiate_ns__Relay(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:167 */
#ifndef SOAP_TYPE_ns__Sensor
#define SOAP_TYPE_ns__Sensor (38)
/* complex XSD type 'ns:Sensor': */
class SOAP_CMAC ns__Sensor {
      public:
        /// Optional element 'sensorNikeName' of XSD type 'xsd:string'
        std::string sensorNikeName;	///< default = ""
        /// Optional element 'sensorValue' of XSD type 'xsd:double'
        double sensorValue;	///< default = 0
        /// Optional element 'sensorCalibration' of XSD type 'xsd:int'
        int sensorCalibration;	///< default = 0
        /// Optional element 'sensorMinimumValue' of XSD type 'xsd:int'
        int sensorMinimumValue;	///< default = 0
        /// Optional element 'sensorMaximumValue' of XSD type 'xsd:int'
        int sensorMaximumValue;	///< default = 0
        /// Optional element 'sensorMaximumThreshold' of XSD type 'xsd:int'
        int sensorMaximumThreshold;	///< default = 0
        /// Optional element 'sensorMinimumThreshold' of XSD type 'xsd:int'
        int sensorMinimumThreshold;	///< default = 0
        /// Optional element 'sensorSMSOnOff' of XSD type 'xsd:boolean'
        bool sensorSMSOnOff;	///< default = (bool)0
        /// Optional element 'sensorBuzzerOnOff' of XSD type 'xsd:boolean'
        bool sensorBuzzerOnOff;	///< default = (bool)0
        /// Required element 'sensorRelay' of XSD type 'ns:Relay'
        ns__Relay sensorRelay;
        /// Optional element 'sensorLEDFlag' of XSD type 'xsd:boolean'
        bool sensorLEDFlag;	///< default = (bool)0
        /// Optional element 'sensorType' of XSD type 'ns:SensorType'
        enum ns__SensorType sensorType;	///< default = (enum ns__SensorType)0
        /// Required element 'sensorError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode sensorError;
      public:
        /// Return unique type id SOAP_TYPE_ns__Sensor
        virtual int soap_type(void) const { return SOAP_TYPE_ns__Sensor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__Sensor, default initialized and not managed by a soap context
        virtual ns__Sensor *soap_alloc(void) const { return SOAP_NEW(ns__Sensor); }
      public:
        /// Constructor with initializations
        ns__Sensor()
        {
          sensorNikeName = "";
          sensorValue = 0;
          sensorCalibration = 0;
          sensorMinimumValue = 0;
          sensorMaximumValue = 0;
          sensorMaximumThreshold = 0;
          sensorMinimumThreshold = 0;
          sensorSMSOnOff = (bool)0;
          sensorBuzzerOnOff = (bool)0;
          sensorLEDFlag = (bool)0;
          sensorType = (enum ns__SensorType)0;
        }
        virtual ~ns__Sensor() { }
        /// Friend allocator used by soap_new_ns__Sensor(struct soap*, int)
        friend SOAP_FMAC1 ns__Sensor * SOAP_FMAC2 Server_Soap_instantiate_ns__Sensor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:184 */
#ifndef SOAP_TYPE_ns__SensorExtension
#define SOAP_TYPE_ns__SensorExtension (40)
/* complex XSD type 'ns:SensorExtension': */
class SOAP_CMAC ns__SensorExtension {
      public:
        /// Optional element 'sensorName' of XSD type 'ns:SensorName'
        enum ns__SensorName sensorName;	///< default = (enum ns__SensorName)0
        /// Optional element 'deviceSensors' of XSD type 'ns:Sensor'
        std::vector<ns__Sensor> deviceSensors;
      public:
        /// Return unique type id SOAP_TYPE_ns__SensorExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns__SensorExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__SensorExtension, default initialized and not managed by a soap context
        virtual ns__SensorExtension *soap_alloc(void) const { return SOAP_NEW(ns__SensorExtension); }
      public:
        /// Constructor with initializations
        ns__SensorExtension()
        {
          sensorName = (enum ns__SensorName)0;
        }
        virtual ~ns__SensorExtension() { }
        /// Friend allocator used by soap_new_ns__SensorExtension(struct soap*, int)
        friend SOAP_FMAC1 ns__SensorExtension * SOAP_FMAC2 Server_Soap_instantiate_ns__SensorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:190 */
#ifndef SOAP_TYPE_ns__Camera
#define SOAP_TYPE_ns__Camera (42)
/* complex XSD type 'ns:Camera': */
class SOAP_CMAC ns__Camera {
      public:
        /// Optional element 'cameraName' of XSD type 'xsd:string'
        std::string cameraName;	///< default = ""
        /// Optional element 'cameraSocket' of XSD type 'xsd:int'
        int cameraSocket;	///< default = 0
        /// Required element 'cameraIP' of XSD type 'ns:IP'
        ns__IP cameraIP;
        /// Optional element 'cameraPort' of XSD type 'xsd:int'
        int cameraPort;	///< default = 0
        /// Required element 'cameraError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode cameraError;
      public:
        /// Return unique type id SOAP_TYPE_ns__Camera
        virtual int soap_type(void) const { return SOAP_TYPE_ns__Camera; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__Camera, default initialized and not managed by a soap context
        virtual ns__Camera *soap_alloc(void) const { return SOAP_NEW(ns__Camera); }
      public:
        /// Constructor with initializations
        ns__Camera()
        {
          cameraName = "";
          cameraSocket = 0;
          cameraPort = 0;
        }
        virtual ~ns__Camera() { }
        /// Friend allocator used by soap_new_ns__Camera(struct soap*, int)
        friend SOAP_FMAC1 ns__Camera * SOAP_FMAC2 Server_Soap_instantiate_ns__Camera(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:199 */
#ifndef SOAP_TYPE_ns__PicturePart
#define SOAP_TYPE_ns__PicturePart (43)
/* complex XSD type 'ns:PicturePart': */
class SOAP_CMAC ns__PicturePart {
      public:
        /// Required element 'partIndex' of XSD type 'xsd:int'
        int partIndex;
        /// Required element 'partData' of XSD type 'xsd:string'
        std::string partData;
        /// Required element 'partCRC' of XSD type 'xsd:int'
        int partCRC;
      public:
        /// Return unique type id SOAP_TYPE_ns__PicturePart
        virtual int soap_type(void) const { return SOAP_TYPE_ns__PicturePart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__PicturePart, default initialized and not managed by a soap context
        virtual ns__PicturePart *soap_alloc(void) const { return SOAP_NEW(ns__PicturePart); }
      public:
        /// Constructor with initializations
        ns__PicturePart()
        {
          partIndex = (int)0;
          partCRC = (int)0;
        }
        virtual ~ns__PicturePart() { }
        /// Friend allocator used by soap_new_ns__PicturePart(struct soap*, int)
        friend SOAP_FMAC1 ns__PicturePart * SOAP_FMAC2 Server_Soap_instantiate_ns__PicturePart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:206 */
#ifndef SOAP_TYPE_ns__Picture
#define SOAP_TYPE_ns__Picture (44)
/* complex XSD type 'ns:Picture': */
class SOAP_CMAC ns__Picture {
      public:
        /// Optional element 'pictureSize' of XSD type 'xsd:int'
        int pictureSize;	///< default = 0
        /// Optional element 'picturePartSize' of XSD type 'xsd:int'
        int picturePartSize;	///< default = 0
        /// Optional element 'picturePartNumbers' of XSD type 'xsd:int'
        int picturePartNumbers;	///< default = 0
        /// Optional element 'pictureCRC' of XSD type 'xsd:int'
        int pictureCRC;	///< default = 0
        /// Optional element 'pictureParts' of XSD type 'ns:PicturePart'
        std::vector<ns__PicturePart> pictureParts;
      public:
        /// Return unique type id SOAP_TYPE_ns__Picture
        virtual int soap_type(void) const { return SOAP_TYPE_ns__Picture; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__Picture, default initialized and not managed by a soap context
        virtual ns__Picture *soap_alloc(void) const { return SOAP_NEW(ns__Picture); }
      public:
        /// Constructor with initializations
        ns__Picture()
        {
          pictureSize = 0;
          picturePartSize = 0;
          picturePartNumbers = 0;
          pictureCRC = 0;
        }
        virtual ~ns__Picture() { }
        /// Friend allocator used by soap_new_ns__Picture(struct soap*, int)
        friend SOAP_FMAC1 ns__Picture * SOAP_FMAC2 Server_Soap_instantiate_ns__Picture(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:215 */
#ifndef SOAP_TYPE_ns__Request
#define SOAP_TYPE_ns__Request (46)
/* complex XSD type 'ns:Request': */
class SOAP_CMAC ns__Request {
      public:
        /// Optional element 'requestRequestType' of XSD type 'ns:RequestType'
        enum ns__RequestType requestRequestType;	///< default = (enum ns__RequestType)1
      public:
        /// Return unique type id SOAP_TYPE_ns__Request
        virtual int soap_type(void) const { return SOAP_TYPE_ns__Request; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__Request, default initialized and not managed by a soap context
        virtual ns__Request *soap_alloc(void) const { return SOAP_NEW(ns__Request); }
      public:
        /// Constructor with initializations
        ns__Request()
        {
          requestRequestType = (enum ns__RequestType)1;
        }
        virtual ~ns__Request() { }
        /// Friend allocator used by soap_new_ns__Request(struct soap*, int)
        friend SOAP_FMAC1 ns__Request * SOAP_FMAC2 Server_Soap_instantiate_ns__Request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:220 */
#ifndef SOAP_TYPE_ns__Device
#define SOAP_TYPE_ns__Device (47)
/* complex XSD type 'ns:Device': */
class SOAP_CMAC ns__Device {
      public:
        /// Optional element 'deviceSerialNumber' of XSD type 'xsd:int'
        int deviceSerialNumber;	///< default = 0
        /// Optional element 'deviceModel' of XSD type 'ns:DeviceModel'
        enum ns__DeviceModel deviceModel;	///< default = (enum ns__DeviceModel)1
        /// Optional element 'deviceName' of XSD type 'xsd:string'
        std::string deviceName;	///< default = ""
        /// Optional element 'deviceFirmWareVersion' of XSD type 'xsd:string'
        std::string deviceFirmWareVersion;	///< default = ""
        /// Optional element 'deviceNikeName' of XSD type 'xsd:string'
        std::string deviceNikeName;	///< default = ""
        /// Optional element 'deviceLocation' of XSD type 'xsd:string'
        std::string deviceLocation;	///< default = ""
        /// Optional element 'deviceCity' of XSD type 'xsd:string'
        std::string deviceCity;	///< default = ""
        /// Optional element 'deviceSocket' of XSD type 'xsd:int'
        int deviceSocket;	///< default = 0
        /// Required element 'deviceDNSAddress' of XSD type 'xsd:string'
        std::string deviceDNSAddress;
        /// Required element 'deviceIP' of XSD type 'ns:IP'
        ns__IP deviceIP;
        /// Optional element 'devicePort' of XSD type 'xsd:int'
        int devicePort;	///< default = 0
        /// Required element 'deviceDateTime' of XSD type 'xsd:dateTime'
        time_t deviceDateTime;
        /// Required element 'deviceMobileInfo' of XSD type 'ns:Mobile'
        ns__Mobile deviceMobileInfo;
        /// Required element 'deviceServerInfo' of XSD type 'ns:Server'
        ns__Server deviceServerInfo;
        /// Required element 'deviceCameraInfo' of XSD type 'ns:Camera'
        ns__Camera deviceCameraInfo;
        /// Required element 'deviceGprsInfo' of XSD type 'ns:Gprs'
        ns__Gprs deviceGprsInfo;
        /// Optional element 'deviceSMSContact' of XSD type 'xsd:long'
        std::vector<LONG64> deviceSMSContact;
        /// Optional element 'deviceSMSConfig' of XSD type 'xsd:long'
        std::vector<LONG64> deviceSMSConfig;
        /// Optional element 'deviceFlags' of XSD type 'xsd:string'
        std::string deviceFlags;	///< default = "000000000000000000"
        /// Optional element 'deviceSMSCommand' of XSD type 'xsd:boolean'
        bool deviceSMSCommand;	///< default = (bool)0
        /// Optional element 'deviceGSMCommand' of XSD type 'xsd:boolean'
        bool deviceGSMCommand;	///< default = (bool)0
        /// Optional element 'deviceKeyBoardCommand' of XSD type 'xsd:boolean'
        bool deviceKeyBoardCommand;	///< default = (bool)0
        /// Optional element 'deviceBuzzerOnOff' of XSD type 'xsd:boolean'
        bool deviceBuzzerOnOff;	///< default = (bool)0
        /// Optional element 'deviceReset' of XSD type 'xsd:boolean'
        bool deviceReset;	///< default = (bool)0
        /// Optional element 'deviceSamplingTime' of XSD type 'xsd:int'
        int deviceSamplingTime;	///< default = 60
        /// Required element 'devicePicture' of XSD type 'ns:Picture'
        ns__Picture devicePicture;
        /// Optional element 'deviceRelays' of XSD type 'xsd:boolean'
        std::vector<bool> deviceRelays;
        /// Optional element 'deviceRequests' of XSD type 'ns:Request'
        std::vector<ns__Request> deviceRequests;
        /// Optional element 'deviceSensors' of XSD type 'ns:SensorExtension'
        std::vector<ns__SensorExtension> deviceSensors;
        /// Required element 'deviceError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode deviceError;
        /// Optional element 'deviceTransPower' of XSD type 'xsd:int'
        int deviceTransPower;	///< default = 315
        /// Optional element 'deviceTableCapacity' of XSD type 'xsd:int'
        int deviceTableCapacity;	///< default = 0
        /// Required element 'deviceGPS' of XSD type 'ns:GPS'
        ns__GPS deviceGPS;
        /// Optional element 'deviceKeyType' of XSD type 'xsd:string'
        std::string deviceKeyType;	///< default = ""
      public:
        /// Return unique type id SOAP_TYPE_ns__Device
        virtual int soap_type(void) const { return SOAP_TYPE_ns__Device; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__Device, default initialized and not managed by a soap context
        virtual ns__Device *soap_alloc(void) const { return SOAP_NEW(ns__Device); }
      public:
        /// Constructor with initializations
        ns__Device()
        {
          deviceSerialNumber = 0;
          deviceModel = (enum ns__DeviceModel)1;
          deviceName = "";
          deviceFirmWareVersion = "";
          deviceNikeName = "";
          deviceLocation = "";
          deviceCity = "";
          deviceSocket = 0;
          devicePort = 0;
          deviceDateTime = (time_t)0;
          deviceFlags = "000000000000000000";
          deviceSMSCommand = (bool)0;
          deviceGSMCommand = (bool)0;
          deviceKeyBoardCommand = (bool)0;
          deviceBuzzerOnOff = (bool)0;
          deviceReset = (bool)0;
          deviceSamplingTime = 60;
          deviceTransPower = 315;
          deviceTableCapacity = 0;
          deviceKeyType = "";
        }
        virtual ~ns__Device() { }
        /// Friend allocator used by soap_new_ns__Device(struct soap*, int)
        friend SOAP_FMAC1 ns__Device * SOAP_FMAC2 Server_Soap_instantiate_ns__Device(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:258 */
#ifndef SOAP_TYPE_ns__ReportRange
#define SOAP_TYPE_ns__ReportRange (52)
/* complex XSD type 'ns:ReportRange': */
class SOAP_CMAC ns__ReportRange {
      public:
        /// Required element 'reportStartDate' of XSD type 'xsd:dateTime'
        time_t reportStartDate;
        /// Required element 'reportEndDate' of XSD type 'xsd:dateTime'
        time_t reportEndDate;
      public:
        /// Return unique type id SOAP_TYPE_ns__ReportRange
        virtual int soap_type(void) const { return SOAP_TYPE_ns__ReportRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__ReportRange, default initialized and not managed by a soap context
        virtual ns__ReportRange *soap_alloc(void) const { return SOAP_NEW(ns__ReportRange); }
      public:
        /// Constructor with initializations
        ns__ReportRange()
        {
          reportStartDate = (time_t)0;
          reportEndDate = (time_t)0;
        }
        virtual ~ns__ReportRange() { }
        /// Friend allocator used by soap_new_ns__ReportRange(struct soap*, int)
        friend SOAP_FMAC1 ns__ReportRange * SOAP_FMAC2 Server_Soap_instantiate_ns__ReportRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:264 */
#ifndef SOAP_TYPE_ns__ActivityLog
#define SOAP_TYPE_ns__ActivityLog (53)
/* complex XSD type 'ns:ActivityLog': */
class SOAP_CMAC ns__ActivityLog {
      public:
        /// Required element 'activityLogStartEndDateTime' of XSD type 'ns:ReportRange'
        ns__ReportRange activityLogStartEndDateTime;
        /// Optional element 'activityLogData' of XSD type 'xsd:string'
        std::string activityLogData;	///< default = ""
        /// Required element 'activityLogDevice' of XSD type 'ns:Device'
        ns__Device activityLogDevice;
        /// Required element 'activityLogUser' of XSD type 'ns:User'
        ns__User activityLogUser;
        /// Required element 'activityError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode activityError;
      public:
        /// Return unique type id SOAP_TYPE_ns__ActivityLog
        virtual int soap_type(void) const { return SOAP_TYPE_ns__ActivityLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__ActivityLog, default initialized and not managed by a soap context
        virtual ns__ActivityLog *soap_alloc(void) const { return SOAP_NEW(ns__ActivityLog); }
      public:
        /// Constructor with initializations
        ns__ActivityLog()
        {
          activityLogData = "";
        }
        virtual ~ns__ActivityLog() { }
        /// Friend allocator used by soap_new_ns__ActivityLog(struct soap*, int)
        friend SOAP_FMAC1 ns__ActivityLog * SOAP_FMAC2 Server_Soap_instantiate_ns__ActivityLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:273 */
#ifndef SOAP_TYPE_ns__UserLog
#define SOAP_TYPE_ns__UserLog (54)
/* complex XSD type 'ns:UserLog': */
class SOAP_CMAC ns__UserLog {
      public:
        /// Required element 'userLogStartEndDateTime' of XSD type 'ns:ReportRange'
        ns__ReportRange userLogStartEndDateTime;
        /// Optional element 'userLogData' of XSD type 'xsd:string'
        std::string userLogData;	///< default = ""
        /// Required element 'userLogUser' of XSD type 'ns:User'
        ns__User userLogUser;
        /// Required element 'userLogError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode userLogError;
      public:
        /// Return unique type id SOAP_TYPE_ns__UserLog
        virtual int soap_type(void) const { return SOAP_TYPE_ns__UserLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__UserLog, default initialized and not managed by a soap context
        virtual ns__UserLog *soap_alloc(void) const { return SOAP_NEW(ns__UserLog); }
      public:
        /// Constructor with initializations
        ns__UserLog()
        {
          userLogData = "";
        }
        virtual ~ns__UserLog() { }
        /// Friend allocator used by soap_new_ns__UserLog(struct soap*, int)
        friend SOAP_FMAC1 ns__UserLog * SOAP_FMAC2 Server_Soap_instantiate_ns__UserLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:281 */
#ifndef SOAP_TYPE_ns__DeviceStatusLog
#define SOAP_TYPE_ns__DeviceStatusLog (55)
/* complex XSD type 'ns:DeviceStatusLog': */
class SOAP_CMAC ns__DeviceStatusLog {
      public:
        /// Required element 'statusLogStartEndDateTime' of XSD type 'ns:ReportRange'
        ns__ReportRange statusLogStartEndDateTime;
        /// Required element 'statusLogDevice' of XSD type 'ns:Device'
        ns__Device statusLogDevice;
        /// Required element 'statusLogError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode statusLogError;
      public:
        /// Return unique type id SOAP_TYPE_ns__DeviceStatusLog
        virtual int soap_type(void) const { return SOAP_TYPE_ns__DeviceStatusLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__DeviceStatusLog, default initialized and not managed by a soap context
        virtual ns__DeviceStatusLog *soap_alloc(void) const { return SOAP_NEW(ns__DeviceStatusLog); }
      public:
        /// Constructor with initializations
        ns__DeviceStatusLog()
        {
        }
        virtual ~ns__DeviceStatusLog() { }
        /// Friend allocator used by soap_new_ns__DeviceStatusLog(struct soap*, int)
        friend SOAP_FMAC1 ns__DeviceStatusLog * SOAP_FMAC2 Server_Soap_instantiate_ns__DeviceStatusLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:288 */
#ifndef SOAP_TYPE_ns__DeviceStatusLogList
#define SOAP_TYPE_ns__DeviceStatusLogList (56)
/* complex XSD type 'ns:DeviceStatusLogList': */
class SOAP_CMAC ns__DeviceStatusLogList {
      public:
        /// Optional element 'statusLogListStatus' of XSD type 'ns:DeviceStatusLog'
        std::vector<ns__DeviceStatusLog> statusLogListStatus;
        /// Required element 'statusLogListError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode statusLogListError;
      public:
        /// Return unique type id SOAP_TYPE_ns__DeviceStatusLogList
        virtual int soap_type(void) const { return SOAP_TYPE_ns__DeviceStatusLogList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__DeviceStatusLogList, default initialized and not managed by a soap context
        virtual ns__DeviceStatusLogList *soap_alloc(void) const { return SOAP_NEW(ns__DeviceStatusLogList); }
      public:
        /// Constructor with initializations
        ns__DeviceStatusLogList()
        {
        }
        virtual ~ns__DeviceStatusLogList() { }
        /// Friend allocator used by soap_new_ns__DeviceStatusLogList(struct soap*, int)
        friend SOAP_FMAC1 ns__DeviceStatusLogList * SOAP_FMAC2 Server_Soap_instantiate_ns__DeviceStatusLogList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:295 */
#ifndef SOAP_TYPE_ns__DeviceStatusInfo
#define SOAP_TYPE_ns__DeviceStatusInfo (58)
/* complex XSD type 'ns:DeviceStatusInfo': */
class SOAP_CMAC ns__DeviceStatusInfo {
      public:
        /// Required element 'deviceStatusInfoStartEndDateTime' of XSD type 'ns:ReportRange'
        ns__ReportRange deviceStatusInfoStartEndDateTime;
        /// Optional element 'deviceStatusInfoDevice' of XSD type 'ns:Device'
        std::vector<ns__Device> deviceStatusInfoDevice;
        /// Optional element 'deviceStatusInfoErrorType' of XSD type 'xsd:string'
        std::vector<std::string> deviceStatusInfoErrorType;
      public:
        /// Return unique type id SOAP_TYPE_ns__DeviceStatusInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns__DeviceStatusInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__DeviceStatusInfo, default initialized and not managed by a soap context
        virtual ns__DeviceStatusInfo *soap_alloc(void) const { return SOAP_NEW(ns__DeviceStatusInfo); }
      public:
        /// Constructor with initializations
        ns__DeviceStatusInfo()
        {
        }
        virtual ~ns__DeviceStatusInfo() { }
        /// Friend allocator used by soap_new_ns__DeviceStatusInfo(struct soap*, int)
        friend SOAP_FMAC1 ns__DeviceStatusInfo * SOAP_FMAC2 Server_Soap_instantiate_ns__DeviceStatusInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:302 */
#ifndef SOAP_TYPE_ns__ErrorLog
#define SOAP_TYPE_ns__ErrorLog (61)
/* complex XSD type 'ns:ErrorLog': */
class SOAP_CMAC ns__ErrorLog {
      public:
        /// Required element 'errorLogDateTime' of XSD type 'xsd:dateTime'
        time_t errorLogDateTime;
        /// Required element 'errorLogDevice' of XSD type 'ns:Device'
        ns__Device errorLogDevice;
        /// Optional element 'errorLogType' of XSD type 'xsd:string'
        std::string errorLogType;	///< default = ""
        /// Required element 'errorLogError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode errorLogError;
      public:
        /// Return unique type id SOAP_TYPE_ns__ErrorLog
        virtual int soap_type(void) const { return SOAP_TYPE_ns__ErrorLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__ErrorLog, default initialized and not managed by a soap context
        virtual ns__ErrorLog *soap_alloc(void) const { return SOAP_NEW(ns__ErrorLog); }
      public:
        /// Constructor with initializations
        ns__ErrorLog()
        {
          errorLogDateTime = (time_t)0;
          errorLogType = "";
        }
        virtual ~ns__ErrorLog() { }
        /// Friend allocator used by soap_new_ns__ErrorLog(struct soap*, int)
        friend SOAP_FMAC1 ns__ErrorLog * SOAP_FMAC2 Server_Soap_instantiate_ns__ErrorLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:310 */
#ifndef SOAP_TYPE_ns__DeviceRules
#define SOAP_TYPE_ns__DeviceRules (62)
/* complex XSD type 'ns:DeviceRules': */
class SOAP_CMAC ns__DeviceRules {
      public:
        /// Required element 'userDeviceDevice' of XSD type 'ns:Device'
        ns__Device userDeviceDevice;
        /// Optional element 'userDeviceView' of XSD type 'xsd:boolean'
        bool userDeviceView;	///< default = (bool)0
        /// Optional element 'userDeviceUpdate' of XSD type 'xsd:boolean'
        bool userDeviceUpdate;	///< default = (bool)0
        /// Optional element 'userDeviceDelete' of XSD type 'xsd:boolean'
        bool userDeviceDelete;	///< default = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_ns__DeviceRules
        virtual int soap_type(void) const { return SOAP_TYPE_ns__DeviceRules; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__DeviceRules, default initialized and not managed by a soap context
        virtual ns__DeviceRules *soap_alloc(void) const { return SOAP_NEW(ns__DeviceRules); }
      public:
        /// Constructor with initializations
        ns__DeviceRules()
        {
          userDeviceView = (bool)0;
          userDeviceUpdate = (bool)0;
          userDeviceDelete = (bool)0;
        }
        virtual ~ns__DeviceRules() { }
        /// Friend allocator used by soap_new_ns__DeviceRules(struct soap*, int)
        friend SOAP_FMAC1 ns__DeviceRules * SOAP_FMAC2 Server_Soap_instantiate_ns__DeviceRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:318 */
#ifndef SOAP_TYPE_ns__UserDevices
#define SOAP_TYPE_ns__UserDevices (63)
/* complex XSD type 'ns:UserDevices': */
class SOAP_CMAC ns__UserDevices {
      public:
        /// Optional element 'userDevices' of XSD type 'ns:DeviceRules'
        std::vector<ns__DeviceRules> userDevices;
        /// Required element 'userDeviceError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode userDeviceError;
      public:
        /// Return unique type id SOAP_TYPE_ns__UserDevices
        virtual int soap_type(void) const { return SOAP_TYPE_ns__UserDevices; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__UserDevices, default initialized and not managed by a soap context
        virtual ns__UserDevices *soap_alloc(void) const { return SOAP_NEW(ns__UserDevices); }
      public:
        /// Constructor with initializations
        ns__UserDevices()
        {
        }
        virtual ~ns__UserDevices() { }
        /// Friend allocator used by soap_new_ns__UserDevices(struct soap*, int)
        friend SOAP_FMAC1 ns__UserDevices * SOAP_FMAC2 Server_Soap_instantiate_ns__UserDevices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:324 */
#ifndef SOAP_TYPE_ns__UserDevice
#define SOAP_TYPE_ns__UserDevice (65)
/* complex XSD type 'ns:UserDevice': */
class SOAP_CMAC ns__UserDevice {
      public:
        /// Required element 'userDeviceUser' of XSD type 'ns:User'
        ns__User userDeviceUser;
        /// Required element 'userDeviceDevices' of XSD type 'ns:UserDevices'
        ns__UserDevices userDeviceDevices;
        /// Required element 'userDeviceError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode userDeviceError;
      public:
        /// Return unique type id SOAP_TYPE_ns__UserDevice
        virtual int soap_type(void) const { return SOAP_TYPE_ns__UserDevice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__UserDevice, default initialized and not managed by a soap context
        virtual ns__UserDevice *soap_alloc(void) const { return SOAP_NEW(ns__UserDevice); }
      public:
        /// Constructor with initializations
        ns__UserDevice()
        {
        }
        virtual ~ns__UserDevice() { }
        /// Friend allocator used by soap_new_ns__UserDevice(struct soap*, int)
        friend SOAP_FMAC1 ns__UserDevice * SOAP_FMAC2 Server_Soap_instantiate_ns__UserDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:331 */
#ifndef SOAP_TYPE_ns__DataBaseInfo
#define SOAP_TYPE_ns__DataBaseInfo (66)
/* complex XSD type 'ns:DataBaseInfo': */
class SOAP_CMAC ns__DataBaseInfo {
      public:
        /// Optional element 'dataBaseInfoServerName' of XSD type 'xsd:string'
        std::string dataBaseInfoServerName;	///< default = ""
        /// Optional element 'dataBaseInfoPort' of XSD type 'xsd:int'
        int dataBaseInfoPort;	///< default = 0
        /// Optional element 'dataBaseInfoUserName' of XSD type 'xsd:string'
        std::string dataBaseInfoUserName;	///< default = ""
        /// Optional element 'dataBaseInfoPassWord' of XSD type 'xsd:string'
        std::string dataBaseInfoPassWord;	///< default = ""
        /// Required element 'dataBaseInfoError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode dataBaseInfoError;
      public:
        /// Return unique type id SOAP_TYPE_ns__DataBaseInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns__DataBaseInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__DataBaseInfo, default initialized and not managed by a soap context
        virtual ns__DataBaseInfo *soap_alloc(void) const { return SOAP_NEW(ns__DataBaseInfo); }
      public:
        /// Constructor with initializations
        ns__DataBaseInfo()
        {
          dataBaseInfoServerName = "";
          dataBaseInfoPort = 0;
          dataBaseInfoUserName = "";
          dataBaseInfoPassWord = "";
        }
        virtual ~ns__DataBaseInfo() { }
        /// Friend allocator used by soap_new_ns__DataBaseInfo(struct soap*, int)
        friend SOAP_FMAC1 ns__DataBaseInfo * SOAP_FMAC2 Server_Soap_instantiate_ns__DataBaseInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:340 */
#ifndef SOAP_TYPE_ns__ServerOptions
#define SOAP_TYPE_ns__ServerOptions (67)
/* complex XSD type 'ns:ServerOptions': */
class SOAP_CMAC ns__ServerOptions {
      public:
        /// Required element 'serverOptionsDataBaseInfo' of XSD type 'ns:DataBaseInfo'
        ns__DataBaseInfo serverOptionsDataBaseInfo;
        /// Optional element 'serverOptionsTimeRepeat' of XSD type 'xsd:int'
        int serverOptionsTimeRepeat;	///< default = 0
        /// Required element 'serverOptionsError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode serverOptionsError;
      public:
        /// Return unique type id SOAP_TYPE_ns__ServerOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns__ServerOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__ServerOptions, default initialized and not managed by a soap context
        virtual ns__ServerOptions *soap_alloc(void) const { return SOAP_NEW(ns__ServerOptions); }
      public:
        /// Constructor with initializations
        ns__ServerOptions()
        {
          serverOptionsTimeRepeat = 0;
        }
        virtual ~ns__ServerOptions() { }
        /// Friend allocator used by soap_new_ns__ServerOptions(struct soap*, int)
        friend SOAP_FMAC1 ns__ServerOptions * SOAP_FMAC2 Server_Soap_instantiate_ns__ServerOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:347 */
#ifndef SOAP_TYPE_ns__CityLocation
#define SOAP_TYPE_ns__CityLocation (68)
/* complex XSD type 'ns:CityLocation': */
class SOAP_CMAC ns__CityLocation {
      public:
        /// Optional element 'cityLocationCityName' of XSD type 'xsd:string'
        std::string cityLocationCityName;	///< default = ""
        /// Optional element 'cityLocationLocationsName' of XSD type 'xsd:string'
        std::vector<std::string> cityLocationLocationsName;
        /// Required element 'cityLocationError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode cityLocationError;
      public:
        /// Return unique type id SOAP_TYPE_ns__CityLocation
        virtual int soap_type(void) const { return SOAP_TYPE_ns__CityLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__CityLocation, default initialized and not managed by a soap context
        virtual ns__CityLocation *soap_alloc(void) const { return SOAP_NEW(ns__CityLocation); }
      public:
        /// Constructor with initializations
        ns__CityLocation()
        {
          cityLocationCityName = "";
        }
        virtual ~ns__CityLocation() { }
        /// Friend allocator used by soap_new_ns__CityLocation(struct soap*, int)
        friend SOAP_FMAC1 ns__CityLocation * SOAP_FMAC2 Server_Soap_instantiate_ns__CityLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:354 */
#ifndef SOAP_TYPE_ns__AllCityLocatoins
#define SOAP_TYPE_ns__AllCityLocatoins (70)
/* complex XSD type 'ns:AllCityLocatoins': */
class SOAP_CMAC ns__AllCityLocatoins {
      public:
        /// Optional element 'allCityLocatoins' of XSD type 'ns:CityLocation'
        std::vector<ns__CityLocation> allCityLocatoins;
        /// Required element 'allCityLocatoinsError' of XSD type 'ns:ErrorCode'
        ns__ErrorCode allCityLocatoinsError;
      public:
        /// Return unique type id SOAP_TYPE_ns__AllCityLocatoins
        virtual int soap_type(void) const { return SOAP_TYPE_ns__AllCityLocatoins; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__AllCityLocatoins, default initialized and not managed by a soap context
        virtual ns__AllCityLocatoins *soap_alloc(void) const { return SOAP_NEW(ns__AllCityLocatoins); }
      public:
        /// Constructor with initializations
        ns__AllCityLocatoins()
        {
        }
        virtual ~ns__AllCityLocatoins() { }
        /// Friend allocator used by soap_new_ns__AllCityLocatoins(struct soap*, int)
        friend SOAP_FMAC1 ns__AllCityLocatoins * SOAP_FMAC2 Server_Soap_instantiate_ns__AllCityLocatoins(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:362 */
#ifndef SOAP_TYPE_ns__GetDeviceStatus
#define SOAP_TYPE_ns__GetDeviceStatus (74)
/* complex XSD type 'ns:GetDeviceStatus': */
struct ns__GetDeviceStatus {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestDeviceInfo' of XSD type 'ns:Device' */
        ns__Device requestDeviceInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetDeviceStatus */
        int soap_type() const { return SOAP_TYPE_ns__GetDeviceStatus; }
        /** Constructor with member initializations */
        ns__GetDeviceStatus()
        {
        }
        /** Friend allocator used by soap_new_ns__GetDeviceStatus(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetDeviceStatus * SOAP_FMAC2 Server_Soap_instantiate_ns__GetDeviceStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:365 */
#ifndef SOAP_TYPE_ns__GetAllDeviceStatus
#define SOAP_TYPE_ns__GetAllDeviceStatus (77)
/* complex XSD type 'ns:GetAllDeviceStatus': */
struct ns__GetAllDeviceStatus {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetAllDeviceStatus */
        int soap_type() const { return SOAP_TYPE_ns__GetAllDeviceStatus; }
        /** Constructor with member initializations */
        ns__GetAllDeviceStatus()
        {
        }
        /** Friend allocator used by soap_new_ns__GetAllDeviceStatus(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetAllDeviceStatus * SOAP_FMAC2 Server_Soap_instantiate_ns__GetAllDeviceStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:368 */
#ifndef SOAP_TYPE_ns__GetDevicePicture
#define SOAP_TYPE_ns__GetDevicePicture (79)
/* complex XSD type 'ns:GetDevicePicture': */
struct ns__GetDevicePicture {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestDeviceInfo' of XSD type 'ns:Device' */
        ns__Device requestDeviceInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetDevicePicture */
        int soap_type() const { return SOAP_TYPE_ns__GetDevicePicture; }
        /** Constructor with member initializations */
        ns__GetDevicePicture()
        {
        }
        /** Friend allocator used by soap_new_ns__GetDevicePicture(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetDevicePicture * SOAP_FMAC2 Server_Soap_instantiate_ns__GetDevicePicture(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:371 */
#ifndef SOAP_TYPE_ns__GetDevicePicturePart
#define SOAP_TYPE_ns__GetDevicePicturePart (81)
/* complex XSD type 'ns:GetDevicePicturePart': */
struct ns__GetDevicePicturePart {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestDeviceInfo' of XSD type 'ns:Device' */
        ns__Device requestDeviceInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetDevicePicturePart */
        int soap_type() const { return SOAP_TYPE_ns__GetDevicePicturePart; }
        /** Constructor with member initializations */
        ns__GetDevicePicturePart()
        {
        }
        /** Friend allocator used by soap_new_ns__GetDevicePicturePart(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetDevicePicturePart * SOAP_FMAC2 Server_Soap_instantiate_ns__GetDevicePicturePart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:374 */
#ifndef SOAP_TYPE_ns__SetDeviceSetting
#define SOAP_TYPE_ns__SetDeviceSetting (84)
/* complex XSD type 'ns:SetDeviceSetting': */
struct ns__SetDeviceSetting {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestDeviceInfo' of XSD type 'ns:Device' */
        ns__Device requestDeviceInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__SetDeviceSetting */
        int soap_type() const { return SOAP_TYPE_ns__SetDeviceSetting; }
        /** Constructor with member initializations */
        ns__SetDeviceSetting()
        {
        }
        /** Friend allocator used by soap_new_ns__SetDeviceSetting(struct soap*, int) */
        friend SOAP_FMAC1 ns__SetDeviceSetting * SOAP_FMAC2 Server_Soap_instantiate_ns__SetDeviceSetting(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:377 */
#ifndef SOAP_TYPE_ns__SetAllDeviceSettingResponse
#define SOAP_TYPE_ns__SetAllDeviceSettingResponse (88)
/* complex XSD type 'ns:SetAllDeviceSettingResponse': */
struct ns__SetAllDeviceSettingResponse {
      public:
        /** Required element 'responseErrorInfo' of XSD type 'ns:ErrorCode' */
        std::vector<ns__ErrorCode> responseErrorInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__SetAllDeviceSettingResponse */
        int soap_type() const { return SOAP_TYPE_ns__SetAllDeviceSettingResponse; }
        /** Constructor with member initializations */
        ns__SetAllDeviceSettingResponse()
        {
        }
        /** Friend allocator used by soap_new_ns__SetAllDeviceSettingResponse(struct soap*, int) */
        friend SOAP_FMAC1 ns__SetAllDeviceSettingResponse * SOAP_FMAC2 Server_Soap_instantiate_ns__SetAllDeviceSettingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:377 */
#ifndef SOAP_TYPE_ns__SetAllDeviceSetting
#define SOAP_TYPE_ns__SetAllDeviceSetting (89)
/* complex XSD type 'ns:SetAllDeviceSetting': */
struct ns__SetAllDeviceSetting {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestDeviceInfo' of XSD type 'ns:Device' */
        std::vector<ns__Device> requestDeviceInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__SetAllDeviceSetting */
        int soap_type() const { return SOAP_TYPE_ns__SetAllDeviceSetting; }
        /** Constructor with member initializations */
        ns__SetAllDeviceSetting()
        {
        }
        /** Friend allocator used by soap_new_ns__SetAllDeviceSetting(struct soap*, int) */
        friend SOAP_FMAC1 ns__SetAllDeviceSetting * SOAP_FMAC2 Server_Soap_instantiate_ns__SetAllDeviceSetting(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:380 */
#ifndef SOAP_TYPE_ns__DeleteDevices
#define SOAP_TYPE_ns__DeleteDevices (91)
/* complex XSD type 'ns:DeleteDevices': */
struct ns__DeleteDevices {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestDeviceList' of XSD type 'ns:Device' */
        std::vector<ns__Device> requestDeviceList;
      public:
        /** Return unique type id SOAP_TYPE_ns__DeleteDevices */
        int soap_type() const { return SOAP_TYPE_ns__DeleteDevices; }
        /** Constructor with member initializations */
        ns__DeleteDevices()
        {
        }
        /** Friend allocator used by soap_new_ns__DeleteDevices(struct soap*, int) */
        friend SOAP_FMAC1 ns__DeleteDevices * SOAP_FMAC2 Server_Soap_instantiate_ns__DeleteDevices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:384 */
#ifndef SOAP_TYPE_ns__Login
#define SOAP_TYPE_ns__Login (94)
/* complex XSD type 'ns:Login': */
struct ns__Login {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__Login */
        int soap_type() const { return SOAP_TYPE_ns__Login; }
        /** Constructor with member initializations */
        ns__Login()
        {
        }
        /** Friend allocator used by soap_new_ns__Login(struct soap*, int) */
        friend SOAP_FMAC1 ns__Login * SOAP_FMAC2 Server_Soap_instantiate_ns__Login(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:387 */
#ifndef SOAP_TYPE_ns__GetUserDeviceList
#define SOAP_TYPE_ns__GetUserDeviceList (96)
/* complex XSD type 'ns:GetUserDeviceList': */
struct ns__GetUserDeviceList {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetUserDeviceList */
        int soap_type() const { return SOAP_TYPE_ns__GetUserDeviceList; }
        /** Constructor with member initializations */
        ns__GetUserDeviceList()
        {
        }
        /** Friend allocator used by soap_new_ns__GetUserDeviceList(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetUserDeviceList * SOAP_FMAC2 Server_Soap_instantiate_ns__GetUserDeviceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:391 */
#ifndef SOAP_TYPE_ns__GetUsersList
#define SOAP_TYPE_ns__GetUsersList (99)
/* complex XSD type 'ns:GetUsersList': */
struct ns__GetUsersList {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetUsersList */
        int soap_type() const { return SOAP_TYPE_ns__GetUsersList; }
        /** Constructor with member initializations */
        ns__GetUsersList()
        {
        }
        /** Friend allocator used by soap_new_ns__GetUsersList(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetUsersList * SOAP_FMAC2 Server_Soap_instantiate_ns__GetUsersList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:394 */
#ifndef SOAP_TYPE_ns__AddUser
#define SOAP_TYPE_ns__AddUser (101)
/* complex XSD type 'ns:AddUser': */
struct ns__AddUser {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestNewUserInfo' of XSD type 'ns:User' */
        ns__User requestNewUserInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__AddUser */
        int soap_type() const { return SOAP_TYPE_ns__AddUser; }
        /** Constructor with member initializations */
        ns__AddUser()
        {
        }
        /** Friend allocator used by soap_new_ns__AddUser(struct soap*, int) */
        friend SOAP_FMAC1 ns__AddUser * SOAP_FMAC2 Server_Soap_instantiate_ns__AddUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:397 */
#ifndef SOAP_TYPE_ns__UpdateUser
#define SOAP_TYPE_ns__UpdateUser (103)
/* complex XSD type 'ns:UpdateUser': */
struct ns__UpdateUser {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestNewUserInfo' of XSD type 'ns:User' */
        ns__User requestNewUserInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__UpdateUser */
        int soap_type() const { return SOAP_TYPE_ns__UpdateUser; }
        /** Constructor with member initializations */
        ns__UpdateUser()
        {
        }
        /** Friend allocator used by soap_new_ns__UpdateUser(struct soap*, int) */
        friend SOAP_FMAC1 ns__UpdateUser * SOAP_FMAC2 Server_Soap_instantiate_ns__UpdateUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:400 */
#ifndef SOAP_TYPE_ns__DeleteUser
#define SOAP_TYPE_ns__DeleteUser (105)
/* complex XSD type 'ns:DeleteUser': */
struct ns__DeleteUser {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestDeleteUserInfo' of XSD type 'ns:User' */
        ns__User requestDeleteUserInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__DeleteUser */
        int soap_type() const { return SOAP_TYPE_ns__DeleteUser; }
        /** Constructor with member initializations */
        ns__DeleteUser()
        {
        }
        /** Friend allocator used by soap_new_ns__DeleteUser(struct soap*, int) */
        friend SOAP_FMAC1 ns__DeleteUser * SOAP_FMAC2 Server_Soap_instantiate_ns__DeleteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:403 */
#ifndef SOAP_TYPE_ns__AssignDeviceToUser
#define SOAP_TYPE_ns__AssignDeviceToUser (107)
/* complex XSD type 'ns:AssignDeviceToUser': */
struct ns__AssignDeviceToUser {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestUserDeviceInfo' of XSD type 'ns:UserDevice' */
        ns__UserDevice requestUserDeviceInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__AssignDeviceToUser */
        int soap_type() const { return SOAP_TYPE_ns__AssignDeviceToUser; }
        /** Constructor with member initializations */
        ns__AssignDeviceToUser()
        {
        }
        /** Friend allocator used by soap_new_ns__AssignDeviceToUser(struct soap*, int) */
        friend SOAP_FMAC1 ns__AssignDeviceToUser * SOAP_FMAC2 Server_Soap_instantiate_ns__AssignDeviceToUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:406 */
#ifndef SOAP_TYPE_ns__DeleteDeviceFromUser
#define SOAP_TYPE_ns__DeleteDeviceFromUser (109)
/* complex XSD type 'ns:DeleteDeviceFromUser': */
struct ns__DeleteDeviceFromUser {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestUserDeviceInfo' of XSD type 'ns:UserDevice' */
        ns__UserDevice requestUserDeviceInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__DeleteDeviceFromUser */
        int soap_type() const { return SOAP_TYPE_ns__DeleteDeviceFromUser; }
        /** Constructor with member initializations */
        ns__DeleteDeviceFromUser()
        {
        }
        /** Friend allocator used by soap_new_ns__DeleteDeviceFromUser(struct soap*, int) */
        friend SOAP_FMAC1 ns__DeleteDeviceFromUser * SOAP_FMAC2 Server_Soap_instantiate_ns__DeleteDeviceFromUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:409 */
#ifndef SOAP_TYPE_ns__GetUserDevices
#define SOAP_TYPE_ns__GetUserDevices (111)
/* complex XSD type 'ns:GetUserDevices': */
struct ns__GetUserDevices {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestSelectedUserInfo' of XSD type 'ns:User' */
        ns__User requestSelectedUserInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetUserDevices */
        int soap_type() const { return SOAP_TYPE_ns__GetUserDevices; }
        /** Constructor with member initializations */
        ns__GetUserDevices()
        {
        }
        /** Friend allocator used by soap_new_ns__GetUserDevices(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetUserDevices * SOAP_FMAC2 Server_Soap_instantiate_ns__GetUserDevices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:413 */
#ifndef SOAP_TYPE_ns__SaveActivityLog
#define SOAP_TYPE_ns__SaveActivityLog (113)
/* complex XSD type 'ns:SaveActivityLog': */
struct ns__SaveActivityLog {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestActivityLogInfo' of XSD type 'ns:ActivityLog' */
        ns__ActivityLog requestActivityLogInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__SaveActivityLog */
        int soap_type() const { return SOAP_TYPE_ns__SaveActivityLog; }
        /** Constructor with member initializations */
        ns__SaveActivityLog()
        {
        }
        /** Friend allocator used by soap_new_ns__SaveActivityLog(struct soap*, int) */
        friend SOAP_FMAC1 ns__SaveActivityLog * SOAP_FMAC2 Server_Soap_instantiate_ns__SaveActivityLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:416 */
#ifndef SOAP_TYPE_ns__GetActivityLogResponse
#define SOAP_TYPE_ns__GetActivityLogResponse (117)
/* complex XSD type 'ns:GetActivityLogResponse': */
struct ns__GetActivityLogResponse {
      public:
        /** Required element 'responseActivityLogInfo' of XSD type 'ns:ActivityLog' */
        std::vector<ns__ActivityLog> responseActivityLogInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetActivityLogResponse */
        int soap_type() const { return SOAP_TYPE_ns__GetActivityLogResponse; }
        /** Constructor with member initializations */
        ns__GetActivityLogResponse()
        {
        }
        /** Friend allocator used by soap_new_ns__GetActivityLogResponse(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetActivityLogResponse * SOAP_FMAC2 Server_Soap_instantiate_ns__GetActivityLogResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:416 */
#ifndef SOAP_TYPE_ns__GetActivityLog
#define SOAP_TYPE_ns__GetActivityLog (118)
/* complex XSD type 'ns:GetActivityLog': */
struct ns__GetActivityLog {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestReportInfo' of XSD type 'ns:ReportRange' */
        ns__ReportRange requestReportInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetActivityLog */
        int soap_type() const { return SOAP_TYPE_ns__GetActivityLog; }
        /** Constructor with member initializations */
        ns__GetActivityLog()
        {
        }
        /** Friend allocator used by soap_new_ns__GetActivityLog(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetActivityLog * SOAP_FMAC2 Server_Soap_instantiate_ns__GetActivityLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:419 */
#ifndef SOAP_TYPE_ns__SaveUserLog
#define SOAP_TYPE_ns__SaveUserLog (120)
/* complex XSD type 'ns:SaveUserLog': */
struct ns__SaveUserLog {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestActivityLogInfo' of XSD type 'ns:UserLog' */
        ns__UserLog requestActivityLogInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__SaveUserLog */
        int soap_type() const { return SOAP_TYPE_ns__SaveUserLog; }
        /** Constructor with member initializations */
        ns__SaveUserLog()
        {
        }
        /** Friend allocator used by soap_new_ns__SaveUserLog(struct soap*, int) */
        friend SOAP_FMAC1 ns__SaveUserLog * SOAP_FMAC2 Server_Soap_instantiate_ns__SaveUserLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:422 */
#ifndef SOAP_TYPE_ns__GetUserLogResponse
#define SOAP_TYPE_ns__GetUserLogResponse (124)
/* complex XSD type 'ns:GetUserLogResponse': */
struct ns__GetUserLogResponse {
      public:
        /** Required element 'responseActivityLogInfo' of XSD type 'ns:UserLog' */
        std::vector<ns__UserLog> responseActivityLogInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetUserLogResponse */
        int soap_type() const { return SOAP_TYPE_ns__GetUserLogResponse; }
        /** Constructor with member initializations */
        ns__GetUserLogResponse()
        {
        }
        /** Friend allocator used by soap_new_ns__GetUserLogResponse(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetUserLogResponse * SOAP_FMAC2 Server_Soap_instantiate_ns__GetUserLogResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:422 */
#ifndef SOAP_TYPE_ns__GetUserLog
#define SOAP_TYPE_ns__GetUserLog (125)
/* complex XSD type 'ns:GetUserLog': */
struct ns__GetUserLog {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestReportInfo' of XSD type 'ns:ReportRange' */
        ns__ReportRange requestReportInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetUserLog */
        int soap_type() const { return SOAP_TYPE_ns__GetUserLog; }
        /** Constructor with member initializations */
        ns__GetUserLog()
        {
        }
        /** Friend allocator used by soap_new_ns__GetUserLog(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetUserLog * SOAP_FMAC2 Server_Soap_instantiate_ns__GetUserLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:425 */
#ifndef SOAP_TYPE_ns__SaveDeviceStatusLog
#define SOAP_TYPE_ns__SaveDeviceStatusLog (127)
/* complex XSD type 'ns:SaveDeviceStatusLog': */
struct ns__SaveDeviceStatusLog {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestStatusLogInfo' of XSD type 'ns:DeviceStatusLog' */
        ns__DeviceStatusLog requestStatusLogInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__SaveDeviceStatusLog */
        int soap_type() const { return SOAP_TYPE_ns__SaveDeviceStatusLog; }
        /** Constructor with member initializations */
        ns__SaveDeviceStatusLog()
        {
        }
        /** Friend allocator used by soap_new_ns__SaveDeviceStatusLog(struct soap*, int) */
        friend SOAP_FMAC1 ns__SaveDeviceStatusLog * SOAP_FMAC2 Server_Soap_instantiate_ns__SaveDeviceStatusLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:428 */
#ifndef SOAP_TYPE_ns__GetDeviceStatusLog
#define SOAP_TYPE_ns__GetDeviceStatusLog (130)
/* complex XSD type 'ns:GetDeviceStatusLog': */
struct ns__GetDeviceStatusLog {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'requestStatusLogInfo' of XSD type 'ns:DeviceStatusInfo' */
        ns__DeviceStatusInfo requestStatusLogInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetDeviceStatusLog */
        int soap_type() const { return SOAP_TYPE_ns__GetDeviceStatusLog; }
        /** Constructor with member initializations */
        ns__GetDeviceStatusLog()
        {
        }
        /** Friend allocator used by soap_new_ns__GetDeviceStatusLog(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetDeviceStatusLog * SOAP_FMAC2 Server_Soap_instantiate_ns__GetDeviceStatusLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:432 */
#ifndef SOAP_TYPE_ns__GetServerOptions
#define SOAP_TYPE_ns__GetServerOptions (133)
/* complex XSD type 'ns:GetServerOptions': */
struct ns__GetServerOptions {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetServerOptions */
        int soap_type() const { return SOAP_TYPE_ns__GetServerOptions; }
        /** Constructor with member initializations */
        ns__GetServerOptions()
        {
        }
        /** Friend allocator used by soap_new_ns__GetServerOptions(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetServerOptions * SOAP_FMAC2 Server_Soap_instantiate_ns__GetServerOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:435 */
#ifndef SOAP_TYPE_ns__SetServerOptions
#define SOAP_TYPE_ns__SetServerOptions (135)
/* complex XSD type 'ns:SetServerOptions': */
struct ns__SetServerOptions {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'serverOptions' of XSD type 'ns:ServerOptions' */
        ns__ServerOptions serverOptions;
      public:
        /** Return unique type id SOAP_TYPE_ns__SetServerOptions */
        int soap_type() const { return SOAP_TYPE_ns__SetServerOptions; }
        /** Constructor with member initializations */
        ns__SetServerOptions()
        {
        }
        /** Friend allocator used by soap_new_ns__SetServerOptions(struct soap*, int) */
        friend SOAP_FMAC1 ns__SetServerOptions * SOAP_FMAC2 Server_Soap_instantiate_ns__SetServerOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:439 */
#ifndef SOAP_TYPE_ns__GetCityAndLocations
#define SOAP_TYPE_ns__GetCityAndLocations (138)
/* complex XSD type 'ns:GetCityAndLocations': */
struct ns__GetCityAndLocations {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetCityAndLocations */
        int soap_type() const { return SOAP_TYPE_ns__GetCityAndLocations; }
        /** Constructor with member initializations */
        ns__GetCityAndLocations()
        {
        }
        /** Friend allocator used by soap_new_ns__GetCityAndLocations(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetCityAndLocations * SOAP_FMAC2 Server_Soap_instantiate_ns__GetCityAndLocations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:442 */
#ifndef SOAP_TYPE_ns__ChangeCityName
#define SOAP_TYPE_ns__ChangeCityName (140)
/* complex XSD type 'ns:ChangeCityName': */
struct ns__ChangeCityName {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'oldCityName' of XSD type 'xsd:string' */
        std::string oldCityName;
        /** Required element 'newCityName' of XSD type 'xsd:string' */
        std::string newCityName;
      public:
        /** Return unique type id SOAP_TYPE_ns__ChangeCityName */
        int soap_type() const { return SOAP_TYPE_ns__ChangeCityName; }
        /** Constructor with member initializations */
        ns__ChangeCityName()
        {
        }
        /** Friend allocator used by soap_new_ns__ChangeCityName(struct soap*, int) */
        friend SOAP_FMAC1 ns__ChangeCityName * SOAP_FMAC2 Server_Soap_instantiate_ns__ChangeCityName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:445 */
#ifndef SOAP_TYPE_ns__ChangeLocationName
#define SOAP_TYPE_ns__ChangeLocationName (142)
/* complex XSD type 'ns:ChangeLocationName': */
struct ns__ChangeLocationName {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'oldCityName' of XSD type 'xsd:string' */
        std::string oldCityName;
        /** Required element 'newCityName' of XSD type 'xsd:string' */
        std::string newCityName;
        /** Required element 'oldLocationName' of XSD type 'xsd:string' */
        std::string oldLocationName;
        /** Required element 'newLocationName' of XSD type 'xsd:string' */
        std::string newLocationName;
      public:
        /** Return unique type id SOAP_TYPE_ns__ChangeLocationName */
        int soap_type() const { return SOAP_TYPE_ns__ChangeLocationName; }
        /** Constructor with member initializations */
        ns__ChangeLocationName()
        {
        }
        /** Friend allocator used by soap_new_ns__ChangeLocationName(struct soap*, int) */
        friend SOAP_FMAC1 ns__ChangeLocationName * SOAP_FMAC2 Server_Soap_instantiate_ns__ChangeLocationName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:448 */
#ifndef SOAP_TYPE_ns__ChangeDeviceName
#define SOAP_TYPE_ns__ChangeDeviceName (144)
/* complex XSD type 'ns:ChangeDeviceName': */
struct ns__ChangeDeviceName {
      public:
        /** Required element 'requestUserInfo' of XSD type 'ns:User' */
        ns__User requestUserInfo;
        /** Required element 'deviceSerialNumber' of XSD type 'xsd:int' */
        int deviceSerialNumber;
        /** Required element 'newCityName' of XSD type 'xsd:string' */
        std::string newCityName;
        /** Required element 'newLocationName' of XSD type 'xsd:string' */
        std::string newLocationName;
        /** Required element 'newDeviceName' of XSD type 'xsd:string' */
        std::string newDeviceName;
      public:
        /** Return unique type id SOAP_TYPE_ns__ChangeDeviceName */
        int soap_type() const { return SOAP_TYPE_ns__ChangeDeviceName; }
        /** Constructor with member initializations */
        ns__ChangeDeviceName()
        {
          deviceSerialNumber = (int)0;
        }
        /** Friend allocator used by soap_new_ns__ChangeDeviceName(struct soap*, int) */
        friend SOAP_FMAC1 ns__ChangeDeviceName * SOAP_FMAC2 Server_Soap_instantiate_ns__ChangeDeviceName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:448 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (145)
/* SOAP_ENV__Header: */
struct SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 Server_Soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:448 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (146)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 Server_Soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:448 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (148)
/* SOAP_ENV__Detail: */
struct SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 Server_Soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:448 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (151)
/* SOAP_ENV__Reason: */
struct SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 Server_Soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:448 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (152)
/* SOAP_ENV__Fault: */
struct SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 Server_Soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* stlvector.h:53 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* stlvector.h:53 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:9 */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (9)
typedef std::string xsd__string;
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:10 */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (10)
typedef int xsd__int;
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:11 */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (12)
typedef bool xsd__boolean;
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:12 */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (14)
typedef double xsd__double;
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:13 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (16)
typedef time_t xsd__dateTime;
#endif

/* F:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h:14 */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (19)
typedef LONG64 xsd__long;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* xsd__int has binding name 'xsd__int' for type 'xsd:int' */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (10)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* long has binding name 'long' for type 'xsd:long' */
#ifndef SOAP_TYPE_long
#define SOAP_TYPE_long (17)
#endif

/* xsd__long has binding name 'xsd__long' for type 'xsd:long' */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (19)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_LONG64
#define SOAP_TYPE_LONG64 (18)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (39)
#endif

/* xsd__double has binding name 'xsd__double' for type 'xsd:double' */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (14)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (13)
#endif

/* xsd__dateTime has binding name 'xsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (16)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (15)
#endif

/* enum ns__KeyType has binding name 'ns__KeyType' for type 'ns:KeyType' */
#ifndef SOAP_TYPE_ns__KeyType
#define SOAP_TYPE_ns__KeyType (27)
#endif

/* enum ns__RequestType has binding name 'ns__RequestType' for type 'ns:RequestType' */
#ifndef SOAP_TYPE_ns__RequestType
#define SOAP_TYPE_ns__RequestType (26)
#endif

/* enum ns__DeviceModel has binding name 'ns__DeviceModel' for type 'ns:DeviceModel' */
#ifndef SOAP_TYPE_ns__DeviceModel
#define SOAP_TYPE_ns__DeviceModel (25)
#endif

/* enum ns__SensorName has binding name 'ns__SensorName' for type 'ns:SensorName' */
#ifndef SOAP_TYPE_ns__SensorName
#define SOAP_TYPE_ns__SensorName (24)
#endif

/* enum ns__SensorType has binding name 'ns__SensorType' for type 'ns:SensorType' */
#ifndef SOAP_TYPE_ns__SensorType
#define SOAP_TYPE_ns__SensorType (23)
#endif

/* enum ns__SimcardType has binding name 'ns__SimcardType' for type 'ns:SimcardType' */
#ifndef SOAP_TYPE_ns__SimcardType
#define SOAP_TYPE_ns__SimcardType (22)
#endif

/* enum ns__UserType has binding name 'ns__UserType' for type 'ns:UserType' */
#ifndef SOAP_TYPE_ns__UserType
#define SOAP_TYPE_ns__UserType (21)
#endif

/* enum ns__SettingLevel has binding name 'ns__SettingLevel' for type 'ns:SettingLevel' */
#ifndef SOAP_TYPE_ns__SettingLevel
#define SOAP_TYPE_ns__SettingLevel (20)
#endif

/* xsd__boolean has binding name 'xsd__boolean' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (12)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (11)
#endif

/* ns__AllCityLocatoins has binding name 'ns__AllCityLocatoins' for type 'ns:AllCityLocatoins' */
#ifndef SOAP_TYPE_ns__AllCityLocatoins
#define SOAP_TYPE_ns__AllCityLocatoins (70)
#endif

/* ns__CityLocation has binding name 'ns__CityLocation' for type 'ns:CityLocation' */
#ifndef SOAP_TYPE_ns__CityLocation
#define SOAP_TYPE_ns__CityLocation (68)
#endif

/* ns__ServerOptions has binding name 'ns__ServerOptions' for type 'ns:ServerOptions' */
#ifndef SOAP_TYPE_ns__ServerOptions
#define SOAP_TYPE_ns__ServerOptions (67)
#endif

/* ns__DataBaseInfo has binding name 'ns__DataBaseInfo' for type 'ns:DataBaseInfo' */
#ifndef SOAP_TYPE_ns__DataBaseInfo
#define SOAP_TYPE_ns__DataBaseInfo (66)
#endif

/* ns__UserDevice has binding name 'ns__UserDevice' for type 'ns:UserDevice' */
#ifndef SOAP_TYPE_ns__UserDevice
#define SOAP_TYPE_ns__UserDevice (65)
#endif

/* ns__UserDevices has binding name 'ns__UserDevices' for type 'ns:UserDevices' */
#ifndef SOAP_TYPE_ns__UserDevices
#define SOAP_TYPE_ns__UserDevices (63)
#endif

/* ns__DeviceRules has binding name 'ns__DeviceRules' for type 'ns:DeviceRules' */
#ifndef SOAP_TYPE_ns__DeviceRules
#define SOAP_TYPE_ns__DeviceRules (62)
#endif

/* ns__ErrorLog has binding name 'ns__ErrorLog' for type 'ns:ErrorLog' */
#ifndef SOAP_TYPE_ns__ErrorLog
#define SOAP_TYPE_ns__ErrorLog (61)
#endif

/* ns__DeviceStatusInfo has binding name 'ns__DeviceStatusInfo' for type 'ns:DeviceStatusInfo' */
#ifndef SOAP_TYPE_ns__DeviceStatusInfo
#define SOAP_TYPE_ns__DeviceStatusInfo (58)
#endif

/* ns__DeviceStatusLogList has binding name 'ns__DeviceStatusLogList' for type 'ns:DeviceStatusLogList' */
#ifndef SOAP_TYPE_ns__DeviceStatusLogList
#define SOAP_TYPE_ns__DeviceStatusLogList (56)
#endif

/* ns__DeviceStatusLog has binding name 'ns__DeviceStatusLog' for type 'ns:DeviceStatusLog' */
#ifndef SOAP_TYPE_ns__DeviceStatusLog
#define SOAP_TYPE_ns__DeviceStatusLog (55)
#endif

/* ns__UserLog has binding name 'ns__UserLog' for type 'ns:UserLog' */
#ifndef SOAP_TYPE_ns__UserLog
#define SOAP_TYPE_ns__UserLog (54)
#endif

/* ns__ActivityLog has binding name 'ns__ActivityLog' for type 'ns:ActivityLog' */
#ifndef SOAP_TYPE_ns__ActivityLog
#define SOAP_TYPE_ns__ActivityLog (53)
#endif

/* ns__ReportRange has binding name 'ns__ReportRange' for type 'ns:ReportRange' */
#ifndef SOAP_TYPE_ns__ReportRange
#define SOAP_TYPE_ns__ReportRange (52)
#endif

/* ns__Device has binding name 'ns__Device' for type 'ns:Device' */
#ifndef SOAP_TYPE_ns__Device
#define SOAP_TYPE_ns__Device (47)
#endif

/* ns__Request has binding name 'ns__Request' for type 'ns:Request' */
#ifndef SOAP_TYPE_ns__Request
#define SOAP_TYPE_ns__Request (46)
#endif

/* ns__Picture has binding name 'ns__Picture' for type 'ns:Picture' */
#ifndef SOAP_TYPE_ns__Picture
#define SOAP_TYPE_ns__Picture (44)
#endif

/* ns__PicturePart has binding name 'ns__PicturePart' for type 'ns:PicturePart' */
#ifndef SOAP_TYPE_ns__PicturePart
#define SOAP_TYPE_ns__PicturePart (43)
#endif

/* ns__Camera has binding name 'ns__Camera' for type 'ns:Camera' */
#ifndef SOAP_TYPE_ns__Camera
#define SOAP_TYPE_ns__Camera (42)
#endif

/* ns__SensorExtension has binding name 'ns__SensorExtension' for type 'ns:SensorExtension' */
#ifndef SOAP_TYPE_ns__SensorExtension
#define SOAP_TYPE_ns__SensorExtension (40)
#endif

/* ns__Sensor has binding name 'ns__Sensor' for type 'ns:Sensor' */
#ifndef SOAP_TYPE_ns__Sensor
#define SOAP_TYPE_ns__Sensor (38)
#endif

/* ns__Relay has binding name 'ns__Relay' for type 'ns:Relay' */
#ifndef SOAP_TYPE_ns__Relay
#define SOAP_TYPE_ns__Relay (37)
#endif

/* ns__Mobile has binding name 'ns__Mobile' for type 'ns:Mobile' */
#ifndef SOAP_TYPE_ns__Mobile
#define SOAP_TYPE_ns__Mobile (36)
#endif

/* ns__GPS has binding name 'ns__GPS' for type 'ns:GPS' */
#ifndef SOAP_TYPE_ns__GPS
#define SOAP_TYPE_ns__GPS (35)
#endif

/* ns__Gprs has binding name 'ns__Gprs' for type 'ns:Gprs' */
#ifndef SOAP_TYPE_ns__Gprs
#define SOAP_TYPE_ns__Gprs (34)
#endif

/* ns__Server has binding name 'ns__Server' for type 'ns:Server' */
#ifndef SOAP_TYPE_ns__Server
#define SOAP_TYPE_ns__Server (33)
#endif

/* ns__IP has binding name 'ns__IP' for type 'ns:IP' */
#ifndef SOAP_TYPE_ns__IP
#define SOAP_TYPE_ns__IP (32)
#endif

/* ns__UsersList has binding name 'ns__UsersList' for type 'ns:UsersList' */
#ifndef SOAP_TYPE_ns__UsersList
#define SOAP_TYPE_ns__UsersList (30)
#endif

/* ns__User has binding name 'ns__User' for type 'ns:User' */
#ifndef SOAP_TYPE_ns__User
#define SOAP_TYPE_ns__User (29)
#endif

/* ns__ErrorCode has binding name 'ns__ErrorCode' for type 'ns:ErrorCode' */
#ifndef SOAP_TYPE_ns__ErrorCode
#define SOAP_TYPE_ns__ErrorCode (28)
#endif

/* xsd__string has binding name 'xsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (9)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (152)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (151)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (148)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (146)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (145)
#endif

/* struct ns__ChangeDeviceName has binding name 'ns__ChangeDeviceName' for type 'ns:ChangeDeviceName' */
#ifndef SOAP_TYPE_ns__ChangeDeviceName
#define SOAP_TYPE_ns__ChangeDeviceName (144)
#endif

/* struct ns__ChangeLocationName has binding name 'ns__ChangeLocationName' for type 'ns:ChangeLocationName' */
#ifndef SOAP_TYPE_ns__ChangeLocationName
#define SOAP_TYPE_ns__ChangeLocationName (142)
#endif

/* struct ns__ChangeCityName has binding name 'ns__ChangeCityName' for type 'ns:ChangeCityName' */
#ifndef SOAP_TYPE_ns__ChangeCityName
#define SOAP_TYPE_ns__ChangeCityName (140)
#endif

/* struct ns__GetCityAndLocations has binding name 'ns__GetCityAndLocations' for type 'ns:GetCityAndLocations' */
#ifndef SOAP_TYPE_ns__GetCityAndLocations
#define SOAP_TYPE_ns__GetCityAndLocations (138)
#endif

/* struct ns__SetServerOptions has binding name 'ns__SetServerOptions' for type 'ns:SetServerOptions' */
#ifndef SOAP_TYPE_ns__SetServerOptions
#define SOAP_TYPE_ns__SetServerOptions (135)
#endif

/* struct ns__GetServerOptions has binding name 'ns__GetServerOptions' for type 'ns:GetServerOptions' */
#ifndef SOAP_TYPE_ns__GetServerOptions
#define SOAP_TYPE_ns__GetServerOptions (133)
#endif

/* struct ns__GetDeviceStatusLog has binding name 'ns__GetDeviceStatusLog' for type 'ns:GetDeviceStatusLog' */
#ifndef SOAP_TYPE_ns__GetDeviceStatusLog
#define SOAP_TYPE_ns__GetDeviceStatusLog (130)
#endif

/* struct ns__SaveDeviceStatusLog has binding name 'ns__SaveDeviceStatusLog' for type 'ns:SaveDeviceStatusLog' */
#ifndef SOAP_TYPE_ns__SaveDeviceStatusLog
#define SOAP_TYPE_ns__SaveDeviceStatusLog (127)
#endif

/* struct ns__GetUserLog has binding name 'ns__GetUserLog' for type 'ns:GetUserLog' */
#ifndef SOAP_TYPE_ns__GetUserLog
#define SOAP_TYPE_ns__GetUserLog (125)
#endif

/* struct ns__GetUserLogResponse has binding name 'ns__GetUserLogResponse' for type 'ns:GetUserLogResponse' */
#ifndef SOAP_TYPE_ns__GetUserLogResponse
#define SOAP_TYPE_ns__GetUserLogResponse (124)
#endif

/* struct ns__SaveUserLog has binding name 'ns__SaveUserLog' for type 'ns:SaveUserLog' */
#ifndef SOAP_TYPE_ns__SaveUserLog
#define SOAP_TYPE_ns__SaveUserLog (120)
#endif

/* struct ns__GetActivityLog has binding name 'ns__GetActivityLog' for type 'ns:GetActivityLog' */
#ifndef SOAP_TYPE_ns__GetActivityLog
#define SOAP_TYPE_ns__GetActivityLog (118)
#endif

/* struct ns__GetActivityLogResponse has binding name 'ns__GetActivityLogResponse' for type 'ns:GetActivityLogResponse' */
#ifndef SOAP_TYPE_ns__GetActivityLogResponse
#define SOAP_TYPE_ns__GetActivityLogResponse (117)
#endif

/* struct ns__SaveActivityLog has binding name 'ns__SaveActivityLog' for type 'ns:SaveActivityLog' */
#ifndef SOAP_TYPE_ns__SaveActivityLog
#define SOAP_TYPE_ns__SaveActivityLog (113)
#endif

/* struct ns__GetUserDevices has binding name 'ns__GetUserDevices' for type 'ns:GetUserDevices' */
#ifndef SOAP_TYPE_ns__GetUserDevices
#define SOAP_TYPE_ns__GetUserDevices (111)
#endif

/* struct ns__DeleteDeviceFromUser has binding name 'ns__DeleteDeviceFromUser' for type 'ns:DeleteDeviceFromUser' */
#ifndef SOAP_TYPE_ns__DeleteDeviceFromUser
#define SOAP_TYPE_ns__DeleteDeviceFromUser (109)
#endif

/* struct ns__AssignDeviceToUser has binding name 'ns__AssignDeviceToUser' for type 'ns:AssignDeviceToUser' */
#ifndef SOAP_TYPE_ns__AssignDeviceToUser
#define SOAP_TYPE_ns__AssignDeviceToUser (107)
#endif

/* struct ns__DeleteUser has binding name 'ns__DeleteUser' for type 'ns:DeleteUser' */
#ifndef SOAP_TYPE_ns__DeleteUser
#define SOAP_TYPE_ns__DeleteUser (105)
#endif

/* struct ns__UpdateUser has binding name 'ns__UpdateUser' for type 'ns:UpdateUser' */
#ifndef SOAP_TYPE_ns__UpdateUser
#define SOAP_TYPE_ns__UpdateUser (103)
#endif

/* struct ns__AddUser has binding name 'ns__AddUser' for type 'ns:AddUser' */
#ifndef SOAP_TYPE_ns__AddUser
#define SOAP_TYPE_ns__AddUser (101)
#endif

/* struct ns__GetUsersList has binding name 'ns__GetUsersList' for type 'ns:GetUsersList' */
#ifndef SOAP_TYPE_ns__GetUsersList
#define SOAP_TYPE_ns__GetUsersList (99)
#endif

/* struct ns__GetUserDeviceList has binding name 'ns__GetUserDeviceList' for type 'ns:GetUserDeviceList' */
#ifndef SOAP_TYPE_ns__GetUserDeviceList
#define SOAP_TYPE_ns__GetUserDeviceList (96)
#endif

/* struct ns__Login has binding name 'ns__Login' for type 'ns:Login' */
#ifndef SOAP_TYPE_ns__Login
#define SOAP_TYPE_ns__Login (94)
#endif

/* struct ns__DeleteDevices has binding name 'ns__DeleteDevices' for type 'ns:DeleteDevices' */
#ifndef SOAP_TYPE_ns__DeleteDevices
#define SOAP_TYPE_ns__DeleteDevices (91)
#endif

/* struct ns__SetAllDeviceSetting has binding name 'ns__SetAllDeviceSetting' for type 'ns:SetAllDeviceSetting' */
#ifndef SOAP_TYPE_ns__SetAllDeviceSetting
#define SOAP_TYPE_ns__SetAllDeviceSetting (89)
#endif

/* struct ns__SetAllDeviceSettingResponse has binding name 'ns__SetAllDeviceSettingResponse' for type 'ns:SetAllDeviceSettingResponse' */
#ifndef SOAP_TYPE_ns__SetAllDeviceSettingResponse
#define SOAP_TYPE_ns__SetAllDeviceSettingResponse (88)
#endif

/* struct ns__SetDeviceSetting has binding name 'ns__SetDeviceSetting' for type 'ns:SetDeviceSetting' */
#ifndef SOAP_TYPE_ns__SetDeviceSetting
#define SOAP_TYPE_ns__SetDeviceSetting (84)
#endif

/* struct ns__GetDevicePicturePart has binding name 'ns__GetDevicePicturePart' for type 'ns:GetDevicePicturePart' */
#ifndef SOAP_TYPE_ns__GetDevicePicturePart
#define SOAP_TYPE_ns__GetDevicePicturePart (81)
#endif

/* struct ns__GetDevicePicture has binding name 'ns__GetDevicePicture' for type 'ns:GetDevicePicture' */
#ifndef SOAP_TYPE_ns__GetDevicePicture
#define SOAP_TYPE_ns__GetDevicePicture (79)
#endif

/* struct ns__GetAllDeviceStatus has binding name 'ns__GetAllDeviceStatus' for type 'ns:GetAllDeviceStatus' */
#ifndef SOAP_TYPE_ns__GetAllDeviceStatus
#define SOAP_TYPE_ns__GetAllDeviceStatus (77)
#endif

/* struct ns__GetDeviceStatus has binding name 'ns__GetDeviceStatus' for type 'ns:GetDeviceStatus' */
#ifndef SOAP_TYPE_ns__GetDeviceStatus
#define SOAP_TYPE_ns__GetDeviceStatus (74)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (154)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (153)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (147)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns__UserLog>  has binding name 'std__vectorTemplateOfns__UserLog' for type 'ns:UserLog' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__UserLog
#define SOAP_TYPE_std__vectorTemplateOfns__UserLog (121)
#endif

/* std::vector<ns__ActivityLog>  has binding name 'std__vectorTemplateOfns__ActivityLog' for type 'ns:ActivityLog' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__ActivityLog
#define SOAP_TYPE_std__vectorTemplateOfns__ActivityLog (114)
#endif

/* std::vector<ns__ErrorCode>  has binding name 'std__vectorTemplateOfns__ErrorCode' for type 'ns:ErrorCode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__ErrorCode
#define SOAP_TYPE_std__vectorTemplateOfns__ErrorCode (85)
#endif

/* std::vector<ns__CityLocation>  has binding name 'std__vectorTemplateOfns__CityLocation' for type 'ns:CityLocation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__CityLocation
#define SOAP_TYPE_std__vectorTemplateOfns__CityLocation (71)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__string
#define SOAP_TYPE_std__vectorTemplateOfxsd__string (69)
#endif

/* std::vector<ns__DeviceRules>  has binding name 'std__vectorTemplateOfns__DeviceRules' for type 'ns:DeviceRules' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__DeviceRules
#define SOAP_TYPE_std__vectorTemplateOfns__DeviceRules (64)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (60)
#endif

/* std::vector<ns__Device>  has binding name 'std__vectorTemplateOfns__Device' for type 'ns:Device' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__Device
#define SOAP_TYPE_std__vectorTemplateOfns__Device (59)
#endif

/* std::vector<ns__DeviceStatusLog>  has binding name 'std__vectorTemplateOfns__DeviceStatusLog' for type 'ns:DeviceStatusLog' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog
#define SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog (57)
#endif

/* std::vector<ns__SensorExtension>  has binding name 'std__vectorTemplateOfns__SensorExtension' for type 'ns:SensorExtension' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__SensorExtension
#define SOAP_TYPE_std__vectorTemplateOfns__SensorExtension (51)
#endif

/* std::vector<ns__Request>  has binding name 'std__vectorTemplateOfns__Request' for type 'ns:Request' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__Request
#define SOAP_TYPE_std__vectorTemplateOfns__Request (50)
#endif

/* std::vector<bool>  has binding name 'std__vectorTemplateOfxsd__boolean' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__boolean
#define SOAP_TYPE_std__vectorTemplateOfxsd__boolean (49)
#endif

/* std::vector<LONG64>  has binding name 'std__vectorTemplateOfxsd__long' for type 'xsd:long' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__long
#define SOAP_TYPE_std__vectorTemplateOfxsd__long (48)
#endif

/* std::vector<ns__PicturePart>  has binding name 'std__vectorTemplateOfns__PicturePart' for type 'ns:PicturePart' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__PicturePart
#define SOAP_TYPE_std__vectorTemplateOfns__PicturePart (45)
#endif

/* std::vector<ns__Sensor>  has binding name 'std__vectorTemplateOfns__Sensor' for type 'ns:Sensor' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__Sensor
#define SOAP_TYPE_std__vectorTemplateOfns__Sensor (41)
#endif

/* std::vector<ns__User>  has binding name 'std__vectorTemplateOfns__User' for type 'ns:User' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__User
#define SOAP_TYPE_std__vectorTemplateOfns__User (31)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/

    /** Web service operation 'ns__GetDeviceStatus' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetDeviceStatus(struct soap*, ns__User requestUserInfo, ns__Device requestDeviceInfo, ns__Device &responseDeviceInfo);
    /** Web service operation 'ns__GetAllDeviceStatus' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetAllDeviceStatus(struct soap*, ns__User requestUserInfo, ns__UserDevice &responseUserDevicesInfo);
    /** Web service operation 'ns__GetDevicePicture' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetDevicePicture(struct soap*, ns__User requestUserInfo, ns__Device requestDeviceInfo, ns__Device &responseDeviceInfo);
    /** Web service operation 'ns__GetDevicePicturePart' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetDevicePicturePart(struct soap*, ns__User requestUserInfo, ns__Device requestDeviceInfo, ns__Device &responseDeviceInfo);
    /** Web service operation 'ns__SetDeviceSetting' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__SetDeviceSetting(struct soap*, ns__User requestUserInfo, ns__Device requestDeviceInfo, ns__ErrorCode &responseErrorInfo);
    /** Web service operation 'ns__SetAllDeviceSetting' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__SetAllDeviceSetting(struct soap*, ns__User requestUserInfo, std::vector<ns__Device> requestDeviceInfo, std::vector<ns__ErrorCode> &responseErrorInfo);
    /** Web service operation 'ns__DeleteDevices' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__DeleteDevices(struct soap*, ns__User requestUserInfo, std::vector<ns__Device> requestDeviceList, ns__ErrorCode &responseErrorInfo);
    /** Web service operation 'ns__Login' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__Login(struct soap*, ns__User requestUserInfo, ns__User &responseUserInfo);
    /** Web service operation 'ns__GetUserDeviceList' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetUserDeviceList(struct soap*, ns__User requestUserInfo, ns__UserDevice &responseUserDevicesInfo);
    /** Web service operation 'ns__GetUsersList' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetUsersList(struct soap*, ns__User requestUserInfo, ns__UsersList &responseUsersList);
    /** Web service operation 'ns__AddUser' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__AddUser(struct soap*, ns__User requestUserInfo, ns__User requestNewUserInfo, ns__ErrorCode &responseErrorInfo);
    /** Web service operation 'ns__UpdateUser' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__UpdateUser(struct soap*, ns__User requestUserInfo, ns__User requestNewUserInfo, ns__ErrorCode &responseErrorInfo);
    /** Web service operation 'ns__DeleteUser' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__DeleteUser(struct soap*, ns__User requestUserInfo, ns__User requestDeleteUserInfo, ns__ErrorCode &responseErrorInfo);
    /** Web service operation 'ns__AssignDeviceToUser' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__AssignDeviceToUser(struct soap*, ns__User requestUserInfo, ns__UserDevice requestUserDeviceInfo, ns__ErrorCode &responseErrorInfo);
    /** Web service operation 'ns__DeleteDeviceFromUser' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__DeleteDeviceFromUser(struct soap*, ns__User requestUserInfo, ns__UserDevice requestUserDeviceInfo, ns__ErrorCode &responseErrorInfo);
    /** Web service operation 'ns__GetUserDevices' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetUserDevices(struct soap*, ns__User requestUserInfo, ns__User requestSelectedUserInfo, ns__UserDevice &responseUserDevicesInfo);
    /** Web service operation 'ns__SaveActivityLog' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__SaveActivityLog(struct soap*, ns__User requestUserInfo, ns__ActivityLog requestActivityLogInfo, ns__ErrorCode &responseErrorInfo);
    /** Web service operation 'ns__GetActivityLog' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetActivityLog(struct soap*, ns__User requestUserInfo, ns__ReportRange requestReportInfo, std::vector<ns__ActivityLog> &responseActivityLogInfo);
    /** Web service operation 'ns__SaveUserLog' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__SaveUserLog(struct soap*, ns__User requestUserInfo, ns__UserLog requestActivityLogInfo, ns__ErrorCode &responseErrorInfo);
    /** Web service operation 'ns__GetUserLog' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetUserLog(struct soap*, ns__User requestUserInfo, ns__ReportRange requestReportInfo, std::vector<ns__UserLog> &responseActivityLogInfo);
    /** Web service operation 'ns__SaveDeviceStatusLog' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__SaveDeviceStatusLog(struct soap*, ns__User requestUserInfo, ns__DeviceStatusLog requestStatusLogInfo, ns__ErrorCode &responseErrorInfo);
    /** Web service operation 'ns__GetDeviceStatusLog' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetDeviceStatusLog(struct soap*, ns__User requestUserInfo, ns__DeviceStatusInfo requestStatusLogInfo, ns__DeviceStatusLogList &responseStatusLogList);
    /** Web service operation 'ns__GetServerOptions' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetServerOptions(struct soap*, ns__User requestUserInfo, ns__ServerOptions &serverOptions);
    /** Web service operation 'ns__SetServerOptions' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__SetServerOptions(struct soap*, ns__User requestUserInfo, ns__ServerOptions serverOptions, ns__ErrorCode &responseErrorInfo);
    /** Web service operation 'ns__GetCityAndLocations' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetCityAndLocations(struct soap*, ns__User requestUserInfo, ns__AllCityLocatoins &responseCityLocationInfo);
    /** Web service operation 'ns__ChangeCityName' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__ChangeCityName(struct soap*, ns__User requestUserInfo, std::string oldCityName, std::string newCityName, ns__ErrorCode &responseErrorInfo);
    /** Web service operation 'ns__ChangeLocationName' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__ChangeLocationName(struct soap*, ns__User requestUserInfo, std::string oldCityName, std::string newCityName, std::string oldLocationName, std::string newLocationName, ns__ErrorCode &responseErrorInfo);
    /** Web service operation 'ns__ChangeDeviceName' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__ChangeDeviceName(struct soap*, ns__User requestUserInfo, int deviceSerialNumber, std::string newCityName, std::string newLocationName, std::string newDeviceName, ns__ErrorCode &responseErrorInfo);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetDeviceStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetAllDeviceStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetDevicePicture(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetDevicePicturePart(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetDeviceSetting(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetAllDeviceSetting(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__DeleteDevices(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__Login(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetUserDeviceList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetUsersList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__AddUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__UpdateUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__DeleteUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__AssignDeviceToUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__DeleteDeviceFromUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetUserDevices(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SaveActivityLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetActivityLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SaveUserLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetUserLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SaveDeviceStatusLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetDeviceStatusLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetServerOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetServerOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetCityAndLocations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__ChangeCityName(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__ChangeLocationName(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__ChangeDeviceName(struct soap*);

#endif

/* End of Server_SoapStub.h */
